<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="John Doe">







<title>Hexo</title>



    <link rel="icon" href="/favicon.ico">



<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=Roboto+Mono&display=swap');
</style>



    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    




    <!-- scripts list from _config.yml -->
    
    <script src="/js/menu.js"></script>
    










  <meta name="generator" content="Hexo 7.3.0"></head>
  <body>
    <div class="mask-border">
    </div>

    <div class="wrapper">

      <div class="header">
  <div class="flex-container">
    <div class="header-inner">
      <div class="site-brand-container">
        <a href="/">
          
            Frame.
          
        </a>
      </div>
      <div id="menu-btn" class="menu-btn" onclick="toggleMenu()">
        Menu
      </div>
      <nav class="site-nav">
        <ul class="menu-list">
          
            
              <li class="menu-item">
                <a href="/">Home</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/archives/">Archive</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/categories/gallery/">Gallery</a>
              </li> 
                   
          
          
        </ul>
      </nav>
    </div>
  </div>
</div>


      <div class="main">
        <div class="flex-container">
          <article id="post">

  
    <div class="post-head">
    <div class="post-info">
        <div class="tag-list">
            
        </div>
        <div class="post-title">
            
            
                *Untitled
            
            
        </div>
        <span class="post-date">
            Feb 20, 2025
        </span>
    </div>
    <div class="post-img">
        
            <div class="h-line-primary"></div>
              
    </div>
</div>
    <div class="post-content">
    <h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p><img src="/../../images/image-20250220092317237.png" alt="image-20250220092317237"></p>
<p><img src="/../../images/image-20250220092331554.png" alt="image-20250220092331554"></p>
<p>多道程序设计技术：在<strong>内存</strong>中放一个及以上作业或程序，使他们在<strong>管理程序的控制下互相穿插地运行</strong>，<strong>共享处理机事件和外部设备</strong>等其他</p>
<p><img src="/../../images/image-20250220092956725.png" alt="image-20250220092956725"></p>
<p>处理机争用、内存分配和保护、IO设备分配、文件的组织和管理、作业管理、用户与系统的接口问题</p>
<p>处理机争用 文件管理 作业管理 内存分配与管理 用户与系统的接口 I&#x2F;O设备分配管理</p>
<p><img src="/../../images/image-20250220094641053.png" alt="image-20250220094641053"></p>
<p><img src="/../../images/image-20250220094702249.png" alt="image-20250220094702249"></p>
<p><img src="/../../images/image-20250220093434509.png" alt="image-20250220093434509"></p>
<p><img src="/../../images/image-20250220093517862.png" alt="image-20250220093517862"></p>
<p><img src="/../../images/image-20250220093533594.png" alt="image-20250220093533594"></p>
<p><img src="/../../images/image-20250220093954784.png" alt="image-20250220093954784"></p>
<h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><p><img src="/../../images/image-20250222182257299.png" alt="image-20250222182257299"></p>
<p>实时系统的问题在于交互性和可靠性；分时系统的问题在于及时性。（总结出来是这三个，具体瞎编。</p>
<p><img src="/../../images/image-20250222183013797.png" alt="image-20250222183013797"></p>
<p>单用户单任务OS: 一个用户 用户程序作为一个任务</p>
<p>单用户多任务OS:一个用户 用户程序分为多个任务并发执行</p>
<p>多用户多任务OS:多个用户在多个终端上控制同一个机器</p>
<p>每个用户程序分为多个任务并发执行 </p>
<p><img src="/../../images/image-20250222183427225.png" alt="image-20250222183427225"></p>
<p>系统调用是OS提供给程序员的唯一接口，通过系统调用，能实现再远程序层调用或释放系统资源，系统调用是一个黑匣子，只提供改变物理硬件的功能而不展示具体动作。</p>
<p>系统调用在内核态，一般用户程序在用户态，库函数是封装的一种方式，是面向应用开发的。</p>
<p><img src="/../../images/image-20250222185146935.png" alt="image-20250222185146935"></p>
<p><img src="/../../images/image-20250222190142611.png" alt="image-20250222190142611"></p>
<p>串行方式+单道程序运行： 这个我不用讲哈，有手就会，注意y轴以工作项目划分（不是一条线） </p>
<p>串行方式+多道程序运行+非抢占式： 不同工作项目可以同时进行，但要注意顺序 同一个程序的两个操作是不能同时进行的 只有不同程序的操作才能同时进行，并且一旦开始了该操作 只有运行完该操作才能开始同道上的下一操作（非抢占） </p>
<p>串行方式+多道程序运行+抢占式： 即优先执行上一个程序的未完成操作 即同道上的操作未执行完，但优先级更高的执行完了要进行写一个任务可以终止当前操作 先执行优先级高的</p>
<p><img src="/../../images/image-20250222190200763.png" alt="image-20250222190200763"></p>
<p><img src="/../../images/image-20250222191254442.png" alt="image-20250222191254442"></p>
<p>OS是一组<strong>控制计算机硬件和软件资源</strong>，对<strong>各类作业进行调度</strong>以方便用户使用的<strong>程序集合</strong>。是配置在计算机硬件上的第一层<strong>系统软件</strong>，是对硬件系统的首次扩充，是<strong>计算机硬件和软件的桥梁</strong>，是用户与计算机硬件进行交互的接口。</p>
<p>特征：并发 共享 虚拟 异步</p>
<p>功能：处理机管理 存储器管理 设备管理 文件管理 接口管理</p>
<p><img src="/../../images/image-20250222191545363.png" alt="image-20250222191545363"></p>
<p>简单，记一下答题话术。</p>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p><img src="/../../images/image-20250222191619384.png" alt="image-20250222191619384"></p>
<h3 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h3><p><img src="/../../images/image-20250222191722618.png" alt="image-20250222191722618"></p>
<p><img src="/../../images/image-20250222194123186.png" alt="image-20250222194123186"></p>
<p><img src="/../../images/image-20250222193953703.png" alt="image-20250222193953703"></p>
<p>挂起状态：无论该状态是否处于就绪状态，都不会被分配给处理机。引入原因：中断用户需要 父进程请求 负荷调节的需要  OS的需要</p>
<p><img src="/../../images/image-20250222194603646.png" alt="image-20250222194603646"></p>
<ol>
<li>调用<strong>进程创建原语</strong></li>
<li>创建一个<strong>空白PCB</strong>，并向该空白PCB写入控<strong>制和管理进程的信息</strong></li>
<li>为进程<strong>分配资源</strong></li>
<li>将PCB转为<strong>就绪状态</strong>并<strong>插入就绪队列</strong></li>
</ol>
<p><img src="/../../images/image-20250222194901531.png" alt="image-20250222194901531"></p>
<p>调用进程终止原语。</p>
<ol>
<li>根据<strong>进程终止标识符</strong>，<strong>找到</strong>PCB集中对应的<strong>PCB</strong>,读出该进程的<strong>状态</strong></li>
<li>若状态为<strong>运行</strong>，<strong>立刻终止</strong>，并将<strong>调度标志写为真</strong>，用于指示该进程应重新被调度</li>
<li>若该进程<strong>有子进程</strong>，<strong>终止</strong>这些子进程，并把他们的<strong>调度标志置位真</strong></li>
<li>将终止进程的<strong>全部资源还给父进程或者系统</strong></li>
<li>将<strong>PCB从队列或链表中移除</strong>，等待其他程序来搜集</li>
</ol>
<p><img src="/../../images/image-20250222195904079.png" alt="image-20250222195904079"></p>
<p>高级系统通信机制：</p>
<ol>
<li><strong>共享存储器</strong> 系统通信机制</li>
<li><strong>管道通信</strong> 系统通信机制</li>
<li><strong>消息传递</strong> 系统通信机制</li>
<li><strong>客户端-服务器</strong> 系统通信机制</li>
</ol>
<p><img src="/../../images/image-20250222200723909.png" alt="image-20250222200723909">不太懂？？啥是传统进程 线程就是现代的？</p>
<p><img src="/../../images/image-20250222200807006.png" alt="image-20250222200807006"></p>
<p>支持进程的数据结构：PCB和队列</p>
<p>支持进程状态变迁的控制原语：创建原语、阻塞原语、唤醒原语、撤销原语</p>
<p>执行进程原语时进程的变化：</p>
<p>创建————无-&gt;就绪</p>
<p>阻塞————就绪-&gt;等待</p>
<p>唤醒————等待-&gt;就绪</p>
<p>撤销————运行-&gt;消亡</p>
<h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><p><img src="/../../images/image-20250221091628551.png" alt="image-20250221091628551"></p>
<p><img src="/../../images/image-20250221091614434.png" alt="image-20250221091614434"></p>
<p><img src="/../../images/image-20250221091658568.png" alt="image-20250221091658568"></p>
<p><img src="/../../images/image-20250221091754333.png" alt="image-20250221091754333"></p>
<p><img src="/../../images/image-20250221092052052.png" alt="image-20250221092052052"></p>
<p><img src="/../../images/image-20250221092812991.png" alt="image-20250221092812991"></p>
<p>等待时间&#x3D;（该进程开始运行时间-到达时间）</p>
<p>平均等待时间&#x3D;（总等待时间）&#x2F;总数</p>
<p>周转时间&#x3D;（该进程结束时间-到达时间）</p>
<p>平均周转时间&#x3D;（总周转时间）&#x2F;总数</p>
<p><strong>主要是看什么调度方式，画运行时间顺序图</strong></p>
<p>这个有点懵（？？看感觉做的不太确定）</p>
<p><img src="/../../images/image-20250221093150671.png" alt="image-20250221093150671"></p>
<h3 id="习题-2"><a href="#习题-2" class="headerlink" title="习题"></a>习题</h3><p><img src="/../../images/image-20250222201441222.png" alt="image-20250222201441222"></p>
<p><img src="/../../images/image-20250222201506947.png" alt="image-20250222201506947"></p>
<p><img src="/../../images/image-20250222201521511.png" alt="image-20250222201521511"></p>
<p><img src="/../../images/image-20250222201537691.png" alt="image-20250222201537691"></p>
<p>带权周转时间&#x3D;周转时间&#x2F;运行时间 **********************************************************</p>
<p>注意这里统一时刻到达，就不用管谁先谁后了，看题目判断谁先谁后。</p>
<p><img src="/../../images/image-20250222201550336.png" alt="image-20250222201550336"></p>
<p><img src="/../../images/image-20250222201609891.png" alt="image-20250222201609891"></p>
<p>产生死锁的原因：</p>
<ol>
<li>资源竞争</li>
<li>进程推进顺序非法</li>
</ol>
<p>产生死锁的必要条件：</p>
<ol>
<li>互斥条件</li>
<li>请求和保持条件</li>
<li>不可抢占条件</li>
<li>循环等待条件</li>
</ol>
<h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><p><img src="/../../images/image-20250222201628201.png" alt="                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        "></p>
<p><img src="/../../images/image-20250223125500845.png" alt="image-20250223125500845"></p>
<p>死锁：进程之间相互等待对方所持有的资源的情况。</p>
<p><img src="/../../images/image-20250223125719598.png" alt="image-20250223125719598"></p>
<p><img src="/../../images/image-20250223125917061.png" alt="image-20250223125917061">空闲让进、忙则等待、有限等待、让权等待</p>
<p><img src="/../../images/image-20250223130353683.png" alt="image-20250223130353683"><img src="/../../images/image-20250223130549700.png" alt="image-20250223130549700">P(S )等待  V(S)释放</p>
<p>S正为空闲，表示当前的空闲资源数； 负为忙，表示当前等待临界区的进程数<img src="/../../images/image-20250223131318997.png" alt="image-20250223131318997"><img src="/../../images/image-20250223131403806.png" alt="image-20250223131403806"><img src="/../../images/image-20250223131827829.png" alt="image-20250223131827829"><img src="/../../images/image-20250223131837368.png" alt="image-20250223131837368"><strong>临界区是进程中用于访问共享资源的那段代码</strong></p>
<h3 id="习题-3"><a href="#习题-3" class="headerlink" title="习题"></a>习题</h3><p><img src="/../../images/image-20250223133252809.png" alt="image-20250223133252809"></p>
<p><img src="/../../images/image-20250223134040229.png" alt="image-20250223134040229">                                    </p>
<p><img src="/../../images/image-20250222201709629.png" alt="image-20250222201709629"></p>
<p><img src="/../../images/image-20250222201730889.png" alt="image-20250222201730889"></p>
<p><img src="/../../images/image-20250222201800164.png" alt="image-20250222201800164"></p>
<p><img src="/../../images/b94797db4ec80e1187e0f3a75d6f88a2_720.jpg" alt="img"></p>
<p><img src="/../../images/image-20250222201806367.png" alt="image-20250222201806367"></p>
<p><img src="/../../images/image-20250222201820467.png" alt="image-20250222201820467"></p>
<p><img src="/../../images/3295cf1b401049bdc024735d24b4ff32.jpg" alt="img"></p>
<h2 id="第五、六章"><a href="#第五、六章" class="headerlink" title="第五、六章"></a>第五、六章</h2><p><img src="/../../images/image-20250223143203572.png" alt="image-20250223143203572"></p>
<p>重定位：<strong>逻辑地址转换为物理地址</strong>的过程，称为重定位。</p>
<p>为什么要重定位？</p>
<p>在软件开发和计算机系统中，重定位是一个至关重要的概念，它确保了程序能够在不同的内存地址上正确运行。以下是对重定位必要性的解释：</p>
<ol>
<li><p><strong>解决内存地址冲突</strong></p>
<ul>
<li><strong>程序与数据的大小不确定</strong>：在计算机系统中，内存地址是有限的资源，而程序和数据的大小是不确定的。为了能够充分利用内存资源，需要将程序和数据放置在不同的内存地址上，以便最大限度地利用空间[^5^]。</li>
<li><strong>动态分配内存</strong>：操作系统或程序员可能会在运行时动态地分配内存给程序，这导致程序的实际加载地址可能与预期的不同。如果程序中包含了直接指向特定内存地址的指令或数据，那么这些指令或数据就需要进行重定位以反映实际的内存布局。</li>
</ul>
</li>
<li><p><strong>提高程序的安全性</strong></p>
<ul>
<li><strong>ASLR防护机制</strong>：地址空间布局随机化（ASLR）是一种安全技术，用于通过随机化程序和数据的内存地址来增加攻击者利用内存漏洞的难度。在这种情况下，程序中的代码和数据需要在加载时进行重定位，以确保它们被放置在随机化的内存位置上。</li>
</ul>
</li>
<li><p><strong>支持模块化编程</strong></p>
<ul>
<li><strong>独立编译与链接</strong>：在大型软件项目中，通常会将代码分解为多个模块进行独立编译和链接。每个模块可能在编译时不知道最终的内存布局，因此需要在链接阶段进行重定位以解决模块之间的地址引用问题。</li>
<li><strong>动态链接库</strong>：动态链接库（DLL）是一种常见的模块化编程技术，允许多个程序共享相同的库代码。当加载DLL时，操作系统需要将其代码和数据映射到进程的地址空间中，并可能需要进行重定位以确保库中的函数和变量能够被正确地调用和访问[^1^]。</li>
</ul>
</li>
<li><p><strong>适应不同平台与架构</strong></p>
<ul>
<li><strong>跨平台兼容性</strong>：不同的计算机平台和架构可能有不同的内存布局和地址ing模式。为了实现跨平台兼容性，编译器和链接器通常需要在生成可执行文件时进行一定程度的抽象和重定位工作，以便在目标平台上能够正确运行。</li>
</ul>
</li>
</ol>
<p>综上所述，重定位是计算机系统中不可或缺的一部分，它解决了内存地址冲突、提高了程序的安全性、支持了模块化编程以及适应了不同平台与架构的需求。</p>
<p>以下是对上述问题的简要回答：</p>
<ol>
<li><p><strong>重定位</strong>：把程序的相对地址空间的逻辑地址转换成存储空间的绝对地址的工作叫做重定位，又叫地址映射或地址变换。重定位的原因主要包括实现程序的可移植性、便于共享内存中的同一程序的副本以及保护操作系统等应用的内存空间[^4^]。</p>
</li>
<li><p><strong>内碎片和外碎片的理解</strong></p>
<ul>
<li><strong>内碎片</strong>：指已经被分配出去（能明确指出属于哪个进程），却不能被利用的内存空间。处于区域内部或页面内部的存储块，占有这些区域或页面的进程并不使用这个存储块。而在进程占有这块存储块时，系统无法利用它，直到进程释放它，或进程结束时，系统才有可能利用这个存储块[^1^][^2^]。</li>
<li><strong>外碎片</strong>：指还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。处于任何两个已分配区域或页面之间的空闲存储块。这些存储块的总和可以满足当前申请的长度要求，但是由于它们的地址不连续或其他原因，使得系统无法满足当前申请[^1^][^2^]。</li>
</ul>
</li>
<li><p><strong>不同存储管理方式产生的碎片</strong></p>
<ul>
<li><strong>连续分配</strong>：单一连续分配方式管理简单，但只能用于单用户、单任务的操作系统中，有内部碎片；固定分区分配方式会因分区内剩余未用空间而产生内部碎片；可变分区分配方式在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要，随着换入换出，越来越多小碎片产生，即外碎片[^4^][^5^]。</li>
<li><strong>非连续分配</strong>：分页式存储管理将一个进程的逻辑地址空间分成若干个大小相等的片，由于进程的最后一页经常装不满一块而形成不可利用的碎片，称之为“页内碎片”；分段式存储管理方式中，作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息，段的长度由相应的逻辑信息组的长度决定，因而各段长度不等，一般只产生外部碎片[^2^][^3^]。</li>
</ul>
</li>
<li><p><strong>页式和段式逻辑地址格式和含义</strong></p>
<ul>
<li><strong>页式逻辑地址</strong>：页式存储管理将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页，并为各页加以编号，从0开始，如第0页、第1页等。相应地，也把内存空间分成与页面相同大小的若干个存储块，称为(物理)块或页框(frame)，也同样为它们加以编号，如0#块、1#块等等。在为进程分配内存时，以块为单位将进程中的若干个页分别装入到多个可以不相邻接的物理块中[^2^][^3^]。</li>
<li><strong>段式逻辑地址</strong>：分段存储管理方式中，作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息。例如，有主程序段MAIN、子程序段X、数据段D及栈段S等。每个段都有自己的名字。为了实现简单起见，通常可用一个段号来代替段名，每个段都从0开始编址，并采用一段连续的地址空间。整个作业的地址空间由于是分成多个段，因而是二维的，亦即，其逻辑地址由段号(段名)和段内地址所组成[^2^]。</li>
</ul>
</li>
<li><p><strong>请求页式存储管理方式的基本原理、地址变换和中断类型</strong></p>
<ul>
<li><strong>基本原理</strong>：请求页式存储管理的基本思想是，在进程开始执行之前，不是装入全部页面，而是只装入一个页面。然后根据进程执行的需要，动态地装入其他页面。地址映射时，当从逻辑地址向物理地址转换时，只将页号p装入到页框号中，而偏移量d则放入页框号对应的页表中。如果本次访问命中，则直接从块号+d对应的物理位置处读出信息；如果本次访问没有命中，则产生缺页中断[^4^]。</li>
<li><strong>地址变换</strong>：在分页系统中，允许将进程的各个页离散地存储在内存不同的物理块中，但系统应能保证进程的正确运行，即能在内存中找到每个页面所对应的物理块。为此，系统又为每个进程建立了一张页面映像表，简称页表。在进程地址空间内的所有页，依次在页表中有一页表项，其中记录了相应页在内存中对应的物理块号。在配置了页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。为了能够将用户地址空间中的逻辑地址，变换为内存空间中的物理地址，在系统中必须设置地址变换机构[^3^]。</li>
<li><strong>中断类型</strong>：缺页中断。这是一种特殊的中断，当需要访问的页面不在内存中时触发。CPU会根据页表中的信息找到所需的页面所在的磁盘位置，并将其加载到内存中的一个空闲页框中，然后更新页表以反映新的映射关系，最后重新启动被中断的指令继续执行[^4^]。</li>
</ul>
</li>
<li><p><strong>请求段式存储管理方式的基本原理、地址变换和中断类型</strong></p>
<ul>
<li><strong>基本原理</strong>：请求段式存储管理方式结合了分段管理和分页管理的优点，首先将用户程序分成若干个段，每个段有自己的名字和长度，然后再将每个段分成若干个页面。这样既方便编程时对程序和数据的组织和管理，又能有效地利用内存空间。当需要访问某个逻辑地址时，系统首先根据段号找到对应的段描述符，再根据段内偏移量找到对应的页表项，最后通过页表项找到物理块号和块内偏移量，从而得到最终的物理地址[^2^]。</li>
<li><strong>地址变换</strong>：请求段式存储管理的地址结构由三部分组成：段号、段内页号和页内位移量。首先根据段号找到段表，然后根据段内页号找到对应的页表，最后根据页内位移量确定最终的物理地址。这种两级映射的方式使得地址转换过程更加灵活，但也增加了系统的复杂性[^2^]。</li>
<li><strong>中断类型</strong>：同请求页式存储管理方式类似，请求段式存储管理方式也会产生缺段中断和缺页中断两种类型的中断。缺段中断发生在当程序试图访问一个未被加载到内存中的段时；缺页中断则发生在当程序试图访问一个已经加载到内存中的段内的某个页面时，但该页面尚未被加载到内存中[^2^]。</li>
</ul>
</li>
<li><p><strong>常见页面置换算法的置换原则</strong></p>
<ul>
<li><p><strong>最佳置换算法（OPT）</strong>：选择不再被使用的或预计未来最长时间内不被访问的页面予以淘汰。这是一种理论上最优的算法，但因为它无法预测未来的情况，实际上很难实现[^4^]。</p>
</li>
<li><p><strong>先进先出置换算法（FIFO）</strong>：总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。该算法容易实现，但没有考虑页面的实际使用情况，可能会淘汰一些经常使用的页面[^4^]。</p>
</li>
<li><p><strong>最近最久未使用置换算法（LRU）</strong>：选择离当前时间最近的一段时间内最久未被访问过的页面进行淘汰。这种算法基于过去的访问记录来推测未来的趋势，认为过去一段时间内没有被访问过的页面将来被访问的可能性较低[^4^]。</p>
</li>
</ul>
</li>
</ol>
<h2 id="视频大题"><a href="#视频大题" class="headerlink" title="视频大题"></a>视频大题</h2><p><img src="/../../images/image-20250223153213610.png" alt="image-20250223153213610"></p>
<p><img src="/../../images/f7c9eefc853b40721f25e7361038fe3b_720.jpg" alt="img"></p>
<p><img src="/../../images/image-20250223155230867.png" alt="image-20250223155230867"></p>
<p><img src="/../../images/image-20250223160013792.png!%5Bimage-20250223161534169%5D(../../images/image-20250223161534169.png" alt="image-20250223160013792"></p>
<p><img src="/../../images/image-20250223161652912.png" alt="image-20250223161652912"></p>
<p>首次适应：从头到尾分配，能放进去则更新起始地址和分区大小</p>
<p>最佳适应：从最小的分配，能放进去则更新起始地址和分区大小</p>
<p>临近适应：从上一次分配的位置的下一位开始，能放进去则更新起始地址和分区大小</p>
<p>最坏适应：从最大的分配，能放进去则更新起始地址和分区大小</p>
<p><img src="/../../images/image-20250223181916946.png" alt="image-20250223181916946"></p>
<p><img src="/../../images/image-20250223183956683.png" alt="image-20250223183956683">末尾，序列满则根据算法置换。**</p>
<p>FIFO算法：先来先算，置换时看相邻最长序列的数字。</p>
<p>LRU算法：置换时从该位置往左数，<strong>最后找齐序列字母</strong>的位置就是要替换的数字。</p>
<p>OPT算法：置换时从该位置<strong>往右</strong>数，<strong>最远找到的字母</strong>就是要替换的字母。</p>
<p>缺页率：缺页次数&#x2F;总次数</p>
<p><img src="/../../images/image-20250223184431896.png" alt="image-20250223184431896"></p>
<p>平均寻道长度&#x3D;寻道走的长度&#x2F;<strong>请求队列数量</strong>（不包括起始位置那个点哈 ）</p>
<p>FCFS先来先服务：按顺序</p>
<p>SSTF最短寻道时间优先：找离当前点的最近点（可左右摇摆）</p>
<p>SCAN电梯：以起始位置为起点，向右走到头后再向左走。</p>
<p>SCS:以起始位置为起点，向右走到头后，再从最左段走到起初位置。</p>
<p><img src="/../../images/2efecddd4d1a46e54e69483ec87796b0_720.jpg" alt=" "></p>
<p><img src="/../../images/image-20250223185908376.png" alt="image-20250223185908376"></p>
<p><img src="/../../images/image-20250223193229496.png!%5Bimage-20250223193540127%5D(../../images/image-20250223193540127.png" alt="image-20250223193229496"></p>
<p>很简单，注意<strong>带权周转时间&#x3D;周转时间&#x2F;运行时间</strong>！不要搞反了。记得<strong>周转时间&#x3D;运行完时刻-到达时间</strong>！</p>
<p>响应比&#x3D;（等待时间+服务时间）&#x2F;服务时间</p>
<p><img src="/../../images/image-20250223193818834.png" alt="image-20250223193818834"></p>
<p><img src="/../../images/image-20250223200050018.png" alt="image-20250223200050018"></p>
<p><img src="/../../images/image-20250223195746173.png!%5Bimg%5D(../../images/083510711365970b217e0be59c0abaf8.jpeg" alt="image-20250223195746173"> </p>
<p>记住表格顺序呀！</p>
<p>当前剩余资源数 请求的资源数 请求对象的已有资源 请求对象释放后的资源</p>
<p>WORK NEED ALLOCATION WORK+ALLOCATION</p>
<p>还有一道题就是PV操作。俺已经会了看看前面就行了。</p>
<h2 id="视频知识点"><a href="#视频知识点" class="headerlink" title="视频知识点"></a>视频知识点</h2><p><img src="/../../images/image-20250223200604270.png" alt="image-20250223200604270"></p>
<p><img src="/../../images/image-20250223200618465.png" alt="image-20250223200618465"></p>
<p><img src="/../../images/image-20250223200629829.png" alt="image-20250223200629829"></p>
<p><img src="/../../images/image-20250223200636808.png" alt="image-20250223200636808"></p>
<p><img src="/../../images/image-20250223200706538.png" alt="image-20250223200706538"></p>
<p><img src="/../../images/image-20250223200713300.png" alt="image-20250223200713300"></p>
<p><img src="/../../images/image-20250223200718985.png" alt="image-20250223200718985"><img src="/../../images/image-20250223200725228.png" alt="image-20250223200725228"></p>
<p><img src="/../../images/image-20250223200731180.png" alt="image-20250223200731180"></p>

</div> 

<script>
    window.onload = detectors();
</script>
    <div class="post-footer">
    <div class="h-line-primary"></div>
    <nav class="post-nav">
        <div class="prev-item">
           
                <div class="icon arrow-left"></div>
                <div class="post-link">
                    <a href="/2025/02/20/%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/react%E5%B8%B8%E7%9C%8B/">Prev</a>
                </div>
            
        </div>
        <div class="next-item">
            
                <div class="icon arrow-right"></div>
                <div class="post-link">
                  <a href="/2025/02/19/%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/%E6%8F%90%E5%8F%96%E5%AF%8C%E6%96%87%E6%9C%AC%E4%B8%AD%E7%9A%84%E6%96%87%E5%AD%97/">Next</a>  
                </div>  
            
        </div>
    </nav>
</div>

    
      <div class="post-comment">

     

     
    
    

</div>
     
  
</article>
        </div>
      </div>
      
      <div class="footer">
    <div class="flex-container">
        <div class="footer-text">
            
            
            
                Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/zoeingwingkei/frame/">Frame</a>
                
        </div>
    </div>
</div>

    </div>

    
    

  </body>
</html>
