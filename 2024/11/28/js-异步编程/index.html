<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="John Doe">







<title>Hexo</title>



    <link rel="icon" href="/favicon.ico">



<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=Roboto+Mono&display=swap');
</style>



    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    




    <!-- scripts list from _config.yml -->
    
    <script src="/js/menu.js"></script>
    










  <meta name="generator" content="Hexo 7.3.0"></head>
  <body>
    <div class="mask-border">
    </div>

    <div class="wrapper">

      <div class="header">
  <div class="flex-container">
    <div class="header-inner">
      <div class="site-brand-container">
        <a href="/">
          
            Frame.
          
        </a>
      </div>
      <div id="menu-btn" class="menu-btn" onclick="toggleMenu()">
        Menu
      </div>
      <nav class="site-nav">
        <ul class="menu-list">
          
            
              <li class="menu-item">
                <a href="/">Home</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/archives/">Archive</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/categories/gallery/">Gallery</a>
              </li> 
                   
          
          
        </ul>
      </nav>
    </div>
  </div>
</div>


      <div class="main">
        <div class="flex-container">
          <article id="post">

  
    <div class="post-head">
    <div class="post-info">
        <div class="tag-list">
            
        </div>
        <div class="post-title">
            
            
                *Untitled
            
            
        </div>
        <span class="post-date">
            Nov 28, 2024
        </span>
    </div>
    <div class="post-img">
        
            <div class="h-line-primary"></div>
              
    </div>
</div>
    <div class="post-content">
    <h2 id="一、同步和异步的区别"><a href="#一、同步和异步的区别" class="headerlink" title="一、同步和异步的区别"></a>一、同步和异步的区别</h2><p>我的总结：</p>
<p><strong>同步</strong>：是在<strong>单线程</strong>的情况下，一个事件执行完之后在执行另一个事件，当前任务未完成时，后续任务将等待。</p>
<p><strong>异步</strong>：也是在<strong>单线程的</strong>情况下，不用等待某一事件执行完，可以把他交给浏览器监听是否需要执行，紧接着执行后面的事件（<strong>不会有堵塞</strong>），一旦浏览器监听到可以执行，<strong>把异步的回调放在主线程的末尾，也是要排队执行的。</strong></p>
<p>因此，在js语言的基础上，<strong>异步做到了并发（单纯能同时执行多项任务）</strong>。他要执行也是需要在主线程进行排队的。只是执行的等待过程可以交给浏览器来管理。</p>
<p><img src="/../images/image-20241129154530853.png" alt="image-20241129154530853"><img src="/../images/image-20241129154618471.png" alt="image-20241129154618471"></p>
<p><strong>并发</strong>：多线程的情况，同一个时间段内，两个或多个程序执行，有时间上的重叠（宏观上是同时，微观上仍是顺序执行）。<strong>【统一时间段但不同一时刻】</strong></p>
<p><strong>并行</strong>：多线程的情况，同时发生的两个并发事件，并行一定并发，但并发不一定并行。<strong>【同一时间段且同一时刻】</strong></p>
<p>补充：<strong>异步并不一定是单线程的</strong>，只是这讨论的是js的异步是单线程的。虽然异步编程模式在某些情况下与单线程相关联，但它们之间并不是等同的关系。</p>
<p>异步操作的核心在于其非阻塞的特性，允许任务在后台执行而不会阻塞程序的继续执行。这种并发处理的方式极大地提高了程序的执行效率和响应速度。异步操作通常涉及到回调函数、事件循环等技术，这些技术在单线程和多线程环境中都可以实现。</p>
<p>在单线程环境中，异步操作通过<strong>事件循环</strong>来调度任务的执行。当某个任务需要等待I&#x2F;O操作时，它不会阻塞整个程序的执行，而是将控制权返回给事件循环，事件循环可以继续调度其他任务执行。这样，即使某个任务在等待I&#x2F;O操作完成，程序也能保持响应性。</p>
<p>然而，在多线程环境中，也可以实现异步操作。在这种情况下，异步任务可能会在不同的线程中并发执行。多线程环境提供了更高的并行处理能力，可以进一步提高程序的执行效率。但是，多线程编程也带来了更复杂的状态管理和同步问题。</p>
<p>因此，异步操作并不局限于单线程环境。它可以在单线程或多线程环境中实现，具体取决于应用程序的需求和设计。在编程实践中，选择同步还是异步、单线程还是多线程，通常需要根据具体的应用场景、性能要求以及开发人员的技能水平来决定。</p>
<h2 id="二、异步函数的演变"><a href="#二、异步函数的演变" class="headerlink" title="二、异步函数的演变"></a>二、异步函数的演变</h2><p>最基础的是异步方法调用异步方法，但如果调用多了会造成代码耦合度过高，不好维护以及可读性差。</p>
<p>回调地域如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">          console.log(&quot;等三秒&quot;);</span><br><span class="line">          setTimeout(function()&#123;</span><br><span class="line">              console.log(&quot;又等三秒&quot;);</span><br><span class="line">                  setTimeout(function()&#123;</span><br><span class="line">                  console.log(&quot;再等三秒&quot;);</span><br><span class="line"></span><br><span class="line">              &#125;,3000)</span><br><span class="line">          &#125;,3000)</span><br><span class="line">      &#125;,3000)</span><br></pre></td></tr></table></figure>

<p>因此，提出了Promise。利用.then来处理异步函数返回的结果，即便多个.then出现，也是<strong>向下延长而不是向右延长</strong>，提升了代码可读性<strong>。尽管catch可以捕获代码异常</strong>，但是无法知晓是在哪一层执行中出现了错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fetch(&quot;http://jsonplaceholder.typicode.com/posts/1&quot;)</span><br><span class="line">        .then((res)=&gt;&#123;res.json()&#125;)</span><br><span class="line">        .then((json)=&gt;console.log(json))</span><br><span class="line">        .catch(e=&gt;console.log(e))</span><br></pre></td></tr></table></figure>

<p>但是多个.then的使用代码阅读也很麻烦，因此提出了async和await语法糖。</p>
<p>async用于<strong>定义函数为异步函数</strong>，返回的结果都为Promise；</p>
<p>而await用于异步函数内部。</p>
<h2 id="三、js设计为单线程的原因"><a href="#三、js设计为单线程的原因" class="headerlink" title="三、js设计为单线程的原因"></a>三、js设计为单线程的原因</h2><p>js是运行在浏览器的脚本。<strong>如果将js设计为多线程，那么可能导致浏览器处理多个DOM事件时引起冲突。</strong>比如一边添加了数量，一边减少了数量，浏览器该怎么解决这两个事件呢？需要设定一套方案来规定优先问题。<strong>因此，js在起初就被设定为单线程语言，只允许一个线程来管理代码的运行</strong>，增加了安全性。</p>
<h2 id="四、事件循环"><a href="#四、事件循环" class="headerlink" title="四、事件循环"></a>四、事件循环</h2><p>js是单线程确立了，又引出了事件等待过长导致后面事件堵塞的问题。因此又提出了同步和异步的概念。同步代码直接执行，<strong>异步代码交给宿主环境托管，触发后将回调函数推入不同队列，根据队列的优先级，会将回调函数推入消息队列，而渲染主线程则会根据先进先出的原则从消息队列取出回调函数，进而执行。</strong></p>
<h3 id="事件循环（全，渡一）"><a href="#事件循环（全，渡一）" class="headerlink" title="事件循环（全，渡一）"></a>事件循环（全，渡一）</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>理解为程序执行的时候需要的内存空间。</p>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>一个进程<strong>至少有一个线程</strong>（这个线程称为主线程），如果程序需要同时执行多块代码，主线程会<strong>启动多线程来执行代码</strong>。</p>
<p><strong>进程&gt;线程</strong></p>
<h4 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h4><p>浏览器是一个<strong>多进程多线程的应用程序</strong>。</p>
<p>为了避免相互影响，减少连环崩坏的几率，<strong>当启动浏览器时，会自动开启多个进程</strong>。</p>
<p><img src="/../images/image-20240926163304252.png" alt="image-20240926163304252"></p>
<ul>
<li>浏览器进程</li>
<li>网络进程</li>
<li><strong>渲染进程</strong>(重点)</li>
</ul>
<p>每开启一个标签页，会开启一个<strong>新的渲染进程</strong>，保证不同标签页之间不相互影响。渲染进程启动后，会开启一个<strong>渲染主线程</strong>，主线程负责执行html、Css、js代码。</p>
<h4 id="如何理解js的异步？"><a href="#如何理解js的异步？" class="headerlink" title="如何理解js的异步？"></a>如何理解js的异步？</h4><p><img src="/../images/image-20240926171346314.png" alt="image-20240926171346314"></p>
<p>例子：</p>
<p>用户点击后，3s后页面改变。因为会产生<strong>绘制的异步任务</strong>，绘制要等待主线程执行完毕后才能进行。</p>
<p><img src="/../images/image-20240926172402887.png" alt="image-20240926172402887"></p>
<h4 id="队列的分类："><a href="#队列的分类：" class="headerlink" title="队列的分类："></a>队列的分类：</h4><p><img src="/../images/image-20240926172909761.png" alt="image-20240926172909761"></p>
<h4 id="阐述一下js的事件循环"><a href="#阐述一下js的事件循环" class="headerlink" title="阐述一下js的事件循环"></a>阐述一下js的事件循环</h4><p><img src="/../images/image-20240926174225278.png" alt="image-20240926174225278"></p>
<h4 id="js中的计时器有偏差吗？为什么？"><a href="#js中的计时器有偏差吗？为什么？" class="headerlink" title="js中的计时器有偏差吗？为什么？"></a>js中的计时器有偏差吗？为什么？</h4><p><img src="/../images/image-20240926175023751.png" alt="image-20240926175023751"></p>
<p><strong>单线程是异步产生的原因</strong></p>
<p><strong>事件循环是异步的实现方式</strong></p>
<p>妈呀醍醐灌顶。。。。。。牛逼事件循环…….</p>
<h3 id="事件循环："><a href="#事件循环：" class="headerlink" title="事件循环："></a><strong>事件循环：</strong></h3><p>总体描述：</p>
<ol>
<li>首先js是单线程的语言，为了防止任务堵塞，出现了异步任务</li>
<li>同步任务交给js引擎来执行，异步任务交给宿主环境来执行</li>
<li>同步代码放入执行栈中；异步任务放入宿主环境，等时机成熟则推入任务队列</li>
<li>执行栈执行完毕后，会去任务队列查看是否有异步任务，如果有则推入执行栈，反复循环查看执行，这个过程就是事件循环。</li>
</ol>
<p>细节描述：</p>
<ol>
<li><p>js在解析时，先把所有的同步任务放进执行栈，（所有异步任务放入宿主环境【浏览器】，等异步任务一触发，就推入任务队列）所有的微任务放入微任务队列，所有的宏任务放入宏任务队列；</p>
</li>
<li><p>首先执行执行栈里的同步任务；</p>
</li>
<li><p>执行栈空后，根据先进先出的原则，把微任务队列的微任务推到执行栈中，执行完后，再看微任务队列是否有任务，如此循环；</p>
</li>
<li><p>微任务队列空后，根据先进先出的原则，把宏任务队列的宏任务推到执行栈中，执行完后，再看宏任务队列是否有任务，如此循环。</p>
</li>
</ol>
<p><img src="/../images/image-20240926154338768.png" alt="image-20240926154338768"></p>
<p><img src="/../images/image-20240924200803929.png" alt="image-20240924200803929"></p>
<p><img src="/../images/image-20240924201331851.png" alt="image-20240924201331851"></p>
<p><strong>执行过程：</strong></p>
<p><img src="/../images/image-20240924201408360.png" alt="image-20240924201408360"></p>
<p><strong>执行过程梳理：</strong></p>
<p><img src="/../images/image-20240924202125684.png" alt="image-20240924202125684"></p>
<p><strong>注意Promise是同步任务，resolve()是标记,都是同步任务。</strong></p>
<p><img src="/../images/image-20240924202538498.png" alt="image-20240924202538498"></p>
<p>没有微任务后，执行宏任务。</p>
<p><img src="/../images/image-20240924202753888.png" alt="image-20240924202753888"></p>
<p>接着，微任务队列里又有了，执行里面的第一个微任务。</p>
<p><img src="/../images/image-20240924202915405.png" alt="image-20240924202915405"></p>
<p>微任务队列里没有任务了，看宏任务。</p>
<p><img src="/../images/image-20240924203030601.png" alt="image-20240924203030601"></p>
<p> 所有任务执行完毕，所以是  1 7 2 4 5 6 3</p>
<h2 id="五、回调函数"><a href="#五、回调函数" class="headerlink" title="五、回调函数"></a>五、回调函数</h2><p><strong>由调用者定义，交给执行者执行的函数</strong></p>
<p><img src="/../images/image-20241129161704433.png" alt="image-20241129161704433"></p>
<h2 id="六、Promise"><a href="#六、Promise" class="headerlink" title="六、Promise"></a>六、Promise</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给出一种承诺，承诺可能成功可能失败，不管成没成功我们都会给予动作回应（回调函数）</p>
<p><img src="/../images/image-20241129161915319.png" alt="image-20241129161915319"></p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//基本使用</span><br><span class="line">       //p= new Promise(fn)</span><br><span class="line">       //p.then(fn,fn) </span><br><span class="line">       const p=new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">           // resolve(&#x27;执行&#x27;);</span><br><span class="line">           reject(new Error(&#x27;promise rejected&#x27;))</span><br><span class="line">       &#125;)</span><br><span class="line">       p.then(res=&gt;&#123;</span><br><span class="line">           console.log(&#x27;resolved&#x27;,res);</span><br><span class="line">           </span><br><span class="line">       &#125;,e=&gt;&#123;</span><br><span class="line">           console.log(&#x27;rejected&#x27;,e);</span><br><span class="line">           </span><br><span class="line">       &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       //利用Promise写ajax请求</span><br><span class="line">       function ajax(url)&#123;</span><br><span class="line">           return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">               var xhr =new XMLHttpRequest()</span><br><span class="line">               xhr.open(&#x27;GET&#x27;,url)</span><br><span class="line">               xhr.responseType=&#x27;json&#x27;</span><br><span class="line">               xhr.onload=function()&#123;</span><br><span class="line">                   if(this.status===200)&#123;</span><br><span class="line">                       resolve(this.response)</span><br><span class="line">                   &#125;else&#123;</span><br><span class="line">                       reject(new Error(this.statusText))</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               xhr.send()</span><br><span class="line">           &#125;)</span><br><span class="line">       &#125;</span><br><span class="line">       ajax(&#x27;/api/user.json&#x27;).then(res=&gt;&#123;</span><br><span class="line">           console.log(res);</span><br><span class="line">       &#125;,err=&gt;&#123;</span><br><span class="line">           console.log(err);</span><br><span class="line">           </span><br><span class="line">       &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>回调函数内的两个函数，一个叫onFulfilled,一个叫onRejected。<img src="/../images/image-20241129165744342.png" alt="image-20241129165744342"></p>
<p><strong>误区</strong>：当需要发送一个请求获取另一个请求的地址时：</p>
<p><img src="/../images/image-20241129165543160.png" alt="image-20241129165543160"></p>
<p>这种想法是错误的。</p>
<p>总结：</p>
<ul>
<li>实际上，Promise的<strong>then方法会返回一个全新的Promise对象</strong>。</li>
<li><strong>每一个then方法</strong>都是在<strong>为上一个then返回的Promise对象</strong>添加<strong>状态明确后的回调</strong>。</li>
<li>前面then方法中<strong>回调函数的返回值</strong>会成为<strong>后面then方法回调的参数</strong>。</li>
<li>如果回调返回的是Promise，那么后面then方法的回调会<strong>等待</strong>他的结束</li>
</ul>
<p><img src="/../images/image-20241129185948910.png" alt="image-20241129185948910"></p>
<p>.then 里面可以返回参数也可以不返回。</p>
<p><strong>如果不返回：</strong>那么<strong>默认返回状态为完成的传递值为Undefined的Promise对象。</strong></p>
<p><strong>如果返回：</strong></p>
<p>​	<strong>若返回的是Promise对象：</strong></p>
<p>​			<strong>对象pending</strong>，则<strong>不会调用后面的then方法</strong>（其实就是必须成功了或者失败了我才好给你调回调函数）；</p>
<p>​			对象resovled或者rejected，调用对应的回调函数，并将resolved的参数或者rejeted的错误原因传递进来；没有值传递打印值就是undefined;</p>
<p>​	<strong>若返回的是其他类型：</strong></p>
<p>​			将该类型<strong>包装成Promise对象</strong>，该值就是Promise对<strong>象传递的值</strong>（相当于<code>return new Promise((resolve,reject)=&gt;&#123;resolve(&lt;该值&gt;)&#125;)</code>或者 <code>Promise.resolve(&lt;该值&gt;)</code>）</p>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>有这两种异常捕获方法。后一种<strong>catch的方式更好</strong>。</p>
<p><img src="/../images/image-20241129191447652.png" alt="image-20241129191447652"></p>
<h4 id="为什么catch捕获效果更好？"><a href="#为什么catch捕获效果更好？" class="headerlink" title="为什么catch捕获效果更好？"></a>为什么catch捕获效果更好？</h4><p><strong>catch是在then链上进行捕获的，</strong>由于.then方法可以传递Promise对象，他是可以<strong>将异常进行传递</strong>的。<strong>使用catch可以同时捕获前面的.then方法回调的异常，防止then回调的代码错误而误认为是第一个Promise对象的错误。</strong></p>
<p>而在then方法中第二个回调函数捕获异常的方法<strong>只能捕获第一个Promise对象的异常，而不能捕获then方法中第一个回调函数的异常。</strong>因此，我们更偏向于用catch捕获所有异常。</p>
<h3 id="Promise静态方法"><a href="#Promise静态方法" class="headerlink" title="Promise静态方法"></a>Promise静态方法</h3><h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h4><p>参数是Promise数组，将<strong>所有结果放在数组并放入Pomise返回</strong>。</p>
<p><strong>所有任务结束</strong>之后才会结束。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//Promise.all([])参数是Promise数组</span><br><span class="line">    var promise=Promise.all([</span><br><span class="line">      ajax(&#x27;/api/toto.json&#x27;),</span><br><span class="line">      ajax(&#x27;/api/yoyo.json&#x27;)</span><br><span class="line">    ])//返回一个Promise对象</span><br><span class="line"></span><br><span class="line">    promise.then(res=&gt;&#123;</span><br><span class="line">      console.log(res);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p><strong>场景</strong>：从一个请求内获取其他请求的url地址。</p>
<p>这个既<strong>涉及then的返回Promise思想，又涉及了Promise.all方法。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//超级厉害的思想。。。。我菜看了都醍醐灌顶</span><br><span class="line">     ajax(&#x27;/api/url.json&#x27;).then(res=&gt;&#123;</span><br><span class="line">       const arr=Object.values(res)</span><br><span class="line">       const promise=arr.map(value=&gt; &#123;           </span><br><span class="line">          return ajax(`/api/$&#123;value&#125;.json`)&#125;</span><br><span class="line">       )</span><br><span class="line">      return Promise.all(promise)</span><br><span class="line">     &#125;).then(res=&gt;&#123;</span><br><span class="line">       console.log(res);</span><br><span class="line">     &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h4><p>参数是Promise数组，将结果放入Pomise返回。</p>
<p><strong>第一个完成的Promise作为结果</strong>返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//   Promise.race()</span><br><span class="line"> const p1=new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">     setTimeout(function()&#123;</span><br><span class="line">         reject(new Error(&#x27;还得练&#x27;))</span><br><span class="line">     &#125;,30)</span><br><span class="line"> &#125;)</span><br><span class="line"> const result=Promise.race([</span><br><span class="line">     ajax(&#x27;/api/toto.json&#x27;),</span><br><span class="line">     p1</span><br><span class="line"> ])</span><br><span class="line"> result.then(res=&gt;&#123;</span><br><span class="line">     console.log(res);</span><br><span class="line"> &#125;).catch(err=&gt;&#123;</span><br><span class="line">     console.log(err);</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="七、genetator"><a href="#七、genetator" class="headerlink" title="七、genetator"></a>七、genetator</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        // 生成器函数</span><br><span class="line">        function * foo()&#123;</span><br><span class="line">            console.log(&#x27;start&#x27;);</span><br><span class="line">            try&#123;</span><br><span class="line">                let res=yield &#x27;foo&#x27; //暂停生成器，直到外界手动调用</span><br><span class="line">                console.log(res);</span><br><span class="line">                </span><br><span class="line">            &#125;catch(e)&#123;</span><br><span class="line">                console.log(e);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        const generator=foo()</span><br><span class="line">        // generator.next(&#x27;bar&#x27;)</span><br><span class="line">        // generator.throw(new Error(&quot;错误&quot;))</span><br><span class="line">        const result=generator.next(&#x27;bar&#x27;)</span><br><span class="line">        console.log(result,&#x27;result&#x27;);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        //generator配合ajax</span><br><span class="line">        function ajax(url)&#123;</span><br><span class="line">            return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">                var xhr =new XMLHttpRequest()</span><br><span class="line">                xhr.open(&#x27;GET&#x27;,url)</span><br><span class="line">                xhr.responseType=&#x27;json&#x27;</span><br><span class="line">                xhr.onload=function()&#123;</span><br><span class="line">                    if(this.status===200)&#123;</span><br><span class="line">                        resolve(this.response)</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        reject(new Error(this.statusText))</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                xhr.send()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        function * main()&#123;</span><br><span class="line">            yield ajax(&#x27;/api/toto.json&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">        let g=main()</span><br><span class="line">        //返回包裹着结果的对象</span><br><span class="line">        const aim=g.next()</span><br><span class="line">        aim.value.then(res=&gt;&#123;</span><br><span class="line">            console.log(res);   </span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>书写递归调用generator：<img src="/../images/image-20241129210442636.png" alt="image-20241129210442636"><img src="/../images/image-20241129210359048.png" alt="image-20241129210359048"></p>
<h2 id="八、async-await"><a href="#八、async-await" class="headerlink" title="八、async&#x2F;await"></a>八、async&#x2F;await</h2><p> 好处：</p>
<p>标准语法</p>
<p>返回一个Promise对象</p>
<p><img src="/../images/image-20241129211512454.png" alt="image-20241129211512454"><img src="/../images/image-20241129211558367.png" alt="image-20241129211558367"></p>
<p><strong>await后面的是一个new Promise对象，后面的一切代码都包装为.then回调</strong>。</p>
<p><strong>await的作用是等待它的这句话的后面的内容是否完成，把不是promise的转化为promise，然后一旦后面的这个内容完成之后，await就把后续的内容推到微任务队列中。</strong></p>
<p><img src="/../images/image-20241130130558635.png" alt="image-20241130130558635"></p>

</div> 

<script>
    window.onload = detectors();
</script>
    <div class="post-footer">
    <div class="h-line-primary"></div>
    <nav class="post-nav">
        <div class="prev-item">
           
                <div class="icon arrow-left"></div>
                <div class="post-link">
                    <a href="/2024/11/30/js-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/">Prev</a>
                </div>
            
        </div>
        <div class="next-item">
            
                <div class="icon arrow-right"></div>
                <div class="post-link">
                  <a href="/2024/11/19/HTML%E5%92%8CCSS/">Next</a>  
                </div>  
            
        </div>
    </nav>
</div>

    
      <div class="post-comment">

     

     
    
    

</div>
     
  
</article>
        </div>
      </div>
      
      <div class="footer">
    <div class="flex-container">
        <div class="footer-text">
            
            
            
                Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/zoeingwingkei/frame/">Frame</a>
                
        </div>
    </div>
</div>

    </div>

    
    

  </body>
</html>
