<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="John Doe">







<title>js精简面试篇 | Hexo</title>



    <link rel="icon" href="/favicon.ico">



<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=Roboto+Mono&display=swap');
</style>



    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    




    <!-- scripts list from _config.yml -->
    
    <script src="/js/menu.js"></script>
    










  <meta name="generator" content="Hexo 7.3.0"></head>
  <body>
    <div class="mask-border">
    </div>

    <div class="wrapper">

      <div class="header">
  <div class="flex-container">
    <div class="header-inner">
      <div class="site-brand-container">
        <a href="/">
          
            Frame.
          
        </a>
      </div>
      <div id="menu-btn" class="menu-btn" onclick="toggleMenu()">
        Menu
      </div>
      <nav class="site-nav">
        <ul class="menu-list">
          
            
              <li class="menu-item">
                <a href="/">Home</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/archives/">Archive</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/categories/gallery/">Gallery</a>
              </li> 
                   
          
          
        </ul>
      </nav>
    </div>
  </div>
</div>


      <div class="main">
        <div class="flex-container">
          <article id="post">

  
    <div class="post-head">
    <div class="post-info">
        <div class="tag-list">
            
        </div>
        <div class="post-title">
            
            
                js精简面试篇
            
            
        </div>
        <span class="post-date">
            Sep 24, 2024
        </span>
    </div>
    <div class="post-img">
        
            <div class="h-line-primary"></div>
              
    </div>
</div>
    <div class="post-content">
    <h1 id="一"><a href="#一" class="headerlink" title="一.&#x3D;&#x3D;&#x3D;"></a>一.&#x3D;&#x3D;&#x3D;</h1><p>对于简单数据类型，只判断值和类型即可；</p>
<p>对于复杂数据类型，值、类型和引用地址都要相同才为true。</p>
<h1 id="二-堆栈值传递"><a href="#二-堆栈值传递" class="headerlink" title="二.堆栈值传递"></a>二.堆栈值传递</h1><p><img src="/../images/image-20240924165330231.png" alt="image-20240924165330231"></p>
<p><strong>为什么o.m不是50？</strong></p>
<p>在JavaScript中，<strong>所有参数的传递都可以看作是“值传递”</strong>，但这个“值”的含义对于基本数据类型和引用数据类型是不同的。对于<strong>基本数据类型</strong>，传递的<strong>是值的副本</strong>；对于<strong>引用数据类型</strong>，传递的是对象<strong>引用的副本</strong>，但这个副本和原始引用都指向同一个对象，因此可以通过引用修改对象的属性。然而，如果函数内部尝试改变参数的引用（即让参数指向一个新的对象），那么这个改变不会影响到函数外部的原始引用。</p>
<h1 id="三-深拷贝和浅拷贝"><a href="#三-深拷贝和浅拷贝" class="headerlink" title="三.深拷贝和浅拷贝"></a>三.深拷贝和浅拷贝</h1><h3 id="浅拷贝（Shallow-Copy）"><a href="#浅拷贝（Shallow-Copy）" class="headerlink" title="浅拷贝（Shallow Copy）"></a>浅拷贝（Shallow Copy）</h3><p>浅拷贝是指创建一个新对象，这个新对象有着<strong>原始对象最外层属性值</strong>的一份精确拷贝。<strong>如果属性是基本类型，拷贝的就是基本类型的值；如果属性是引用类型，拷贝的就是内存地址，</strong>因此如果其中一个对象<strong>改变了这个地址引用的内容</strong>，就会<strong>影响</strong>到另一个对象。在JavaScript中，常见的浅拷贝方法包括：</p>
<ul>
<li>直接赋值（但这通常不被视为拷贝，因为它没有创建新对象）</li>
<li>使用扩展运算符（<code>...</code>）进行对象或数组的拷贝</li>
<li>使用<code>Object.assign()</code>方法</li>
<li>使用数组的<code>slice()</code>或<code>concat()</code>方法（对于数组）</li>
</ul>
<h3 id="深拷贝（Deep-Copy）"><a href="#深拷贝（Deep-Copy）" class="headerlink" title="深拷贝（Deep Copy）"></a>深拷贝（Deep Copy）</h3><p>深拷贝<strong>会创建一个新的对象，并递归复制原始对象中的所有嵌套对象</strong>，<strong>直到只包含基本类型的值为止</strong>。这样，新对象和原始对象在内存中是完全独立的，修改新对象不会影响原始对象。在JavaScript中，实现深拷贝的常见方法包括：</p>
<ul>
<li>使用<code>JSON.parse(JSON.stringify())</code>方法（但这种方法有局限性，如无法处理循环引用、函数等特殊对象）</li>
<li>手动编写递归函数进行深拷贝</li>
<li>使用第三方库，如lodash的<code>_.cloneDeep()</code>方法</li>
</ul>
<h2 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, ...sources)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>target</code>：目标对象。</li>
<li><code>sources</code>：一个或多个源对象。</li>
</ul>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>返回目标对象。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;  </span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">4</span>, <span class="attr">c</span>: <span class="number">5</span> &#125;;  </span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">6</span> &#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> returnedTarget = <span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source1, source2);  </span><br><span class="line">  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target);  </span><br><span class="line"><span class="comment">// 输出: Object &#123; a: 1, b: 4, c: 6 &#125;  </span></span><br><span class="line">  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(returnedTarget);  </span><br><span class="line"><span class="comment">// 输出: Object &#123; a: 1, b: 4, c: 6 &#125;  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 注意，target 和 returnedTarget 是同一个对象  </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target === returnedTarget); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><strong>浅拷贝</strong>：<code>Object.assign()</code> 执行的是浅拷贝，而不是深拷贝。如果源对象的属性值是一个对象的引用，那么它只拷贝那个引用值，而不是对象本身。</li>
<li><strong>原始值覆盖</strong>：如果多个源对象具有相同的属性，则后面的源对象属性会覆盖前面的源对象属性。</li>
<li><strong>null 或 undefined 的处理</strong>：如果目标对象是 <code>null</code> 或 <code>undefined</code>，则会抛出 <code>TypeError</code> 异常。</li>
<li><strong>属性的可枚举性</strong>：只有可枚举的自有属性会被拷贝。</li>
<li><strong>性能</strong>：在处理大量属性时，<code>Object.assign()</code> 可能不是最高效的方法，因为它每次调用都会执行一次属性赋值操作。</li>
<li><strong>自定义对象</strong>：如果源对象有 getter，赋值时会调用 getter，并且 getter 的返回值会被用作属性的新值，而不是 getter 函数本身被赋值给目标对象。</li>
<li><strong>原始数据类型</strong>：如果目标对象不是对象（比如是一个字符串或数字），则 <code>Object.assign()</code> 会将其转换为对象，然后返回这个对象。但是，这通常不是期望的行为，因为原始值会被包装成对象，这可能导致意外的结果。</li>
</ol>
<h1 id="四-作用域"><a href="#四-作用域" class="headerlink" title="四.作用域"></a>四.作用域</h1><p><img src="/../images/image-20240924174144123.png" alt="image-20240924174144123"></p>
<p>为什么立即执行函数可以保护作用域？</p>
<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>函数提升&gt;变量提升</p>
<p><img src="/../images/image-20240924174658970.png" alt="image-20240924174658970"></p>
<h2 id="执行上下文的生命周期"><a href="#执行上下文的生命周期" class="headerlink" title="执行上下文的生命周期"></a>执行上下文的生命周期</h2><p><img src="/../images/image-20240924174750603.png" alt="image-20240924174750603"></p>
<h1 id="五-宏任务和微任务"><a href="#五-宏任务和微任务" class="headerlink" title="五.宏任务和微任务"></a>五.宏任务和微任务</h1><p><img src="/../images/image-20240924195941636.png" alt="image-20240924195941636"></p>
<p><strong>注意Promise本身是同步的，而then和catch是异步的！！！</strong></p>
<h2 id="事件循环："><a href="#事件循环：" class="headerlink" title="事件循环："></a><strong>事件循环：</strong></h2><p>总体描述：</p>
<ol>
<li>首先js是单线程的语言，为了防止任务堵塞，出现了异步任务</li>
<li>同步任务交给js引擎来执行，异步任务交给宿主环境来执行</li>
<li>同步代码放入执行栈中；异步任务放入宿主环境，等时机成熟则推入任务队列</li>
<li>执行栈执行完毕后，会去任务队列查看是否有异步任务，如果有则推入执行栈，反复循环查看执行，这个过程就是事件循环。</li>
</ol>
<p>细节描述：</p>
<ol>
<li><p>js在解析时，先把所有的同步任务放进执行栈，（所有异步任务放入宿主环境【浏览器】，等异步任务一触发，就推入任务队列）所有的微任务放入微任务队列，所有的宏任务放入宏任务队列；</p>
</li>
<li><p>首先执行执行栈里的同步任务；</p>
</li>
<li><p>执行栈空后，根据先进先出的原则，把微任务队列的微任务推到执行栈中，执行完后，再看微任务队列是否有任务，如此循环；</p>
</li>
<li><p>微任务队列空后，根据先进先出的原则，把宏任务队列的宏任务推到执行栈中，执行完后，再看宏任务队列是否有任务，如此循环。</p>
</li>
</ol>
<p><img src="/../images/image-20240926154338768.png" alt="image-20240926154338768"></p>
<p><img src="/../images/image-20240924200803929.png" alt="image-20240924200803929"></p>
<p><img src="/../images/image-20240924201331851.png" alt="image-20240924201331851"></p>
<p><strong>执行过程：</strong></p>
<p><img src="/../images/image-20240924201408360.png" alt="image-20240924201408360"></p>
<p><strong>执行过程梳理：</strong></p>
<p><img src="/../images/image-20240924202125684.png" alt="image-20240924202125684"></p>
<p><strong>注意Promise是同步任务，resolve()是标记,都是同步任务。</strong></p>
<p><img src="/../images/image-20240924202538498.png" alt="image-20240924202538498"></p>
<p>没有微任务后，执行宏任务。</p>
<p><img src="/../images/image-20240924202753888.png" alt="image-20240924202753888"></p>
<p>接着，微任务队列里又有了，执行里面的第一个微任务。</p>
<p><img src="/../images/image-20240924202915405.png" alt="image-20240924202915405"></p>
<p>微任务队列里没有任务了，看宏任务。</p>
<p><img src="/../images/image-20240924203030601.png" alt="image-20240924203030601"></p>
<p> 所有任务执行完毕，所以是  1 7 2 4 5 6 3</p>
<h2 id="事件循环（全，渡一）"><a href="#事件循环（全，渡一）" class="headerlink" title="事件循环（全，渡一）"></a>事件循环（全，渡一）</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>理解为程序执行的时候需要的内存空间。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>一个进程<strong>至少有一个线程</strong>（这个线程称为主线程），如果程序需要同时执行多块代码，主线程会<strong>启动多线程来执行代码</strong>。</p>
<p><strong>进程&gt;线程</strong></p>
<h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>浏览器是一个<strong>多进程多线程的应用程序</strong>。</p>
<p>为了避免相互影响，减少连环崩坏的几率，<strong>当启动浏览器时，会自动开启多个进程</strong>。</p>
<p><img src="/../images/image-20240926163304252.png" alt="image-20240926163304252"></p>
<ul>
<li>浏览器进程</li>
<li>网络进程</li>
<li><strong>渲染进程</strong>(重点)</li>
</ul>
<p>每开启一个标签页，会开启一个<strong>新的渲染进程</strong>，保证不同标签页之间不相互影响。渲染进程启动后，会开启一个<strong>渲染主线程</strong>，主线程负责执行html、Css、js代码。</p>
<h3 id="如何理解js的异步？"><a href="#如何理解js的异步？" class="headerlink" title="如何理解js的异步？"></a>如何理解js的异步？</h3><p><img src="/../images/image-20240926171346314.png" alt="image-20240926171346314"></p>
<p>例子：</p>
<p>用户点击后，3s后页面改变。因为会产生<strong>绘制的异步任务</strong>，绘制要等待主线程执行完毕后才能进行。</p>
<p><img src="/../images/image-20240926172402887.png" alt="image-20240926172402887"></p>
<h3 id="队列的分类："><a href="#队列的分类：" class="headerlink" title="队列的分类："></a>队列的分类：</h3><p><img src="/../images/image-20240926172909761.png" alt="image-20240926172909761"></p>
<h3 id="阐述一下js的事件循环"><a href="#阐述一下js的事件循环" class="headerlink" title="阐述一下js的事件循环"></a>阐述一下js的事件循环</h3><p><img src="/../images/image-20240926174225278.png" alt="image-20240926174225278"></p>
<h3 id="js中的计时器有偏差吗？为什么？"><a href="#js中的计时器有偏差吗？为什么？" class="headerlink" title="js中的计时器有偏差吗？为什么？"></a>js中的计时器有偏差吗？为什么？</h3><p><img src="/../images/image-20240926175023751.png" alt="image-20240926175023751"></p>
<p><strong>单线程是异步产生的原因</strong></p>
<p><strong>事件循环是异步的实现方式</strong></p>
<p>妈呀醍醐灌顶。。。。。。牛逼事件循环…….</p>
<h1 id="六-数组方法"><a href="#六-数组方法" class="headerlink" title="六.数组方法"></a>六.数组方法</h1><h2 id="查找方法"><a href="#查找方法" class="headerlink" title="查找方法"></a>查找方法</h2><p>arr.indexOf(value) ——根据索引值查找值</p>
<p>arr.includes(value) ——根据值查找是否存在</p>
<h2 id="伪数组"><a href="#伪数组" class="headerlink" title="伪数组"></a>伪数组</h2><p>伪数组是拥有与数组类似的结构的对象，虽然可以利用索引值获取元素，但不能使数组的方法。</p>
<h3 id="产生伪数组"><a href="#产生伪数组" class="headerlink" title="产生伪数组"></a>产生伪数组</h3><ol>
<li>argument 动态参数</li>
<li>qureySelectorAll 获取DOM元素</li>
<li>等</li>
</ol>
<h3 id="如何将伪数组转化为数组"><a href="#如何将伪数组转化为数组" class="headerlink" title="如何将伪数组转化为数组"></a>如何将伪数组转化为数组</h3><ul>
<li>Array.from()</li>
<li>[…arr] 解构</li>
<li>Array.prototype.slice.call()</li>
</ul>
<p>（slice浅拷贝，将定义在Function原型对象上的方法进行使用，并将伪数组的this传递进去进行拷贝）</p>
<p>slice语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const animals = [&#x27;ant&#x27;, &#x27;bison&#x27;, &#x27;camel&#x27;, &#x27;duck&#x27;, &#x27;elephant&#x27;];</span><br><span class="line"></span><br><span class="line">console.log(animals.slice(2));</span><br><span class="line">// Expected output: Array [&quot;camel&quot;, &quot;duck&quot;, &quot;elephant&quot;]</span><br><span class="line"></span><br><span class="line">console.log(animals.slice(2, 4));</span><br><span class="line">// Expected output: Array [&quot;camel&quot;, &quot;duck&quot;]</span><br><span class="line"></span><br><span class="line">console.log(animals.slice(1, 5));</span><br><span class="line">// Expected output: Array [&quot;bison&quot;, &quot;camel&quot;, &quot;duck&quot;, &quot;elephant&quot;]</span><br><span class="line"></span><br><span class="line">console.log(animals.slice(-2));</span><br><span class="line">// Expected output: Array [&quot;duck&quot;, &quot;elephant&quot;]</span><br><span class="line"></span><br><span class="line">console.log(animals.slice(2, -1));</span><br><span class="line">// Expected output: Array [&quot;camel&quot;, &quot;duck&quot;]</span><br><span class="line"></span><br><span class="line">console.log(animals.slice());</span><br><span class="line">// Expected output: Array [&quot;ant&quot;, &quot;bison&quot;, &quot;camel&quot;, &quot;duck&quot;, &quot;elephant&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="七-宿主对象、内置对象、原生对象"><a href="#七-宿主对象、内置对象、原生对象" class="headerlink" title="七.宿主对象、内置对象、原生对象"></a>七.宿主对象、内置对象、原生对象</h1><p><strong>宿主对象</strong>是程序运行的环境（如浏览器、nodejs）提供的对象。这不是js的核心。</p>
<p>浏览器中包括document window xmlhttprequest。</p>
<p>nodejs中包括global process等。</p>
<p><strong>内置对象</strong>是js提供的对象，可以直接在js环境中使用，无需额外引入或导入。如Math、Date、正则等。</p>
<p><strong>原生对象</strong>是js语言的一部分，但不是内置对象。原生对象是通过构造函数或者字面量方式创建的对象，如arr、obj、function</p>
<h1 id="八-作用域"><a href="#八-作用域" class="headerlink" title="八.作用域"></a>八.作用域</h1><p><strong>作用域其实就是变量能够访问的范围。</strong></p>
<p><strong>作用域链就是底层变量查找的机制。</strong></p>
<p>当查找变量时，会从当前作用域开始查找，如果没有，那么向上一层逐层查找，直到没找到返回null </p>
<h1 id="九-class"><a href="#九-class" class="headerlink" title="九.class"></a>九.class</h1><p>class继承父类，利用extends关键字实现继承。继承后，可以使用super调用父类的初始化函数，而父类的方法子类的初始化对象可以直接使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">	constructor(name)&#123;</span><br><span class="line">		this.name=name</span><br><span class="line">	&#125;</span><br><span class="line">	drink()&#123;</span><br><span class="line">		console.log(&quot;喝水&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Student extends Person&#123; //extends继承父类</span><br><span class="line">	constructor(name,score)&#123;</span><br><span class="line">		super(name)</span><br><span class="line">		this.score=score</span><br><span class="line">	&#125;</span><br><span class="line">	introduce()&#123;</span><br><span class="line">		console.log(`我是$&#123;this.name&#125;,今年$&#123;this.score&#125;分`)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const stu=new Student(&#x27;toto&#x27;,99)</span><br><span class="line">console.log(stu)</span><br><span class="line">stu.introduce()</span><br><span class="line">stu.drink()</span><br></pre></td></tr></table></figure>

<h1 id="十、同步和异步的区别"><a href="#十、同步和异步的区别" class="headerlink" title="十、同步和异步的区别"></a>十、同步和异步的区别</h1><p>我的总结：</p>
<p><strong>同步</strong>：是在<strong>单线程</strong>的情况下，一个事件执行完之后在执行另一个事件，当前任务未完成时，后续任务将等待。</p>
<p><strong>异步</strong>：也是在<strong>单线程的</strong>情况下，不用等待某一事件执行完，可以把他交给浏览器监听是否需要执行，紧接着执行后面的事件（<strong>不会有堵塞</strong>），一旦浏览器监听到可以执行，<strong>把异步的回调放在主线程的末尾，也是要排队执行的。</strong></p>
<p>因此，在js语言的基础上，<strong>异步不是并行或者并发</strong>。他要执行也是需要在主线程进行排队的。只是执行的等待过程可以交给浏览器来管理。</p>
<p><strong>并发</strong>：多线程的情况，同一个时间段内，两个或多个程序执行，有时间上的重叠（宏观上是同时，微观上仍是顺序执行）。<strong>【统一时间段但不同一时刻】</strong></p>
<p><strong>并行</strong>：多线程的情况，同时发生的两个并发事件，并行一定并发，但并发不一定并行。<strong>【同一时间段且同一时刻】</strong></p>
<p>补充：<strong>异步并不一定是单线程的</strong>，只是这讨论的是js的异步是单线程的。虽然异步编程模式在某些情况下与单线程相关联，但它们之间并不是等同的关系。</p>
<p>异步操作的核心在于其非阻塞的特性，允许任务在后台执行而不会阻塞程序的继续执行。这种并发处理的方式极大地提高了程序的执行效率和响应速度。异步操作通常涉及到回调函数、事件循环等技术，这些技术在单线程和多线程环境中都可以实现。</p>
<p>在单线程环境中，异步操作通过<strong>事件循环</strong>来调度任务的执行。当某个任务需要等待I&#x2F;O操作时，它不会阻塞整个程序的执行，而是将控制权返回给事件循环，事件循环可以继续调度其他任务执行。这样，即使某个任务在等待I&#x2F;O操作完成，程序也能保持响应性。</p>
<p>然而，在多线程环境中，也可以实现异步操作。在这种情况下，异步任务可能会在不同的线程中并发执行。多线程环境提供了更高的并行处理能力，可以进一步提高程序的执行效率。但是，多线程编程也带来了更复杂的状态管理和同步问题。</p>
<p>因此，异步操作并不局限于单线程环境。它可以在单线程或多线程环境中实现，具体取决于应用程序的需求和设计。在编程实践中，选择同步还是异步、单线程还是多线程，通常需要根据具体的应用场景、性能要求以及开发人员的技能水平来决定。</p>
<ol>
<li>并行</li>
</ol>
<p>  ：</p>
<ul>
<li>并行是指在同一时刻，有多个任务或进程在同时执行。这通常发生在多处理器或多核处理器系统中，每个处理器或核心可以独立地执行一个任务或进程。</li>
<li>并行关注的是任务的真正同时执行，以充分利用多处理器或多核处理器的计算能力。</li>
</ul>
<h1 id="十一-AJAX"><a href="#十一-AJAX" class="headerlink" title="十一.AJAX"></a>十一.AJAX</h1><h3 id="对Ajax的理解"><a href="#对Ajax的理解" class="headerlink" title="对Ajax的理解"></a>对Ajax的理解</h3><p>Ajax，全称为Asynchronous JavaScript and XML（异步JavaScript和XML），是一种用于创建更快、更动态网页应用的技术。Ajax允许网页在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页内容。这意味着用户可以在不中断当前操作的情况下，请求新的数据或提交表单。</p>
<p>Ajax的核心是XMLHttpRequest对象（在现代浏览器中，也可以使用更现代的fetch API，但XMLHttpRequest仍然是理解和Ajax的基础）。这个对象可以在不刷新页面的情况下，从服务器请求数据、发送数据或两者兼而有之。服务器返回的数据可以是XML格式，但也可以是JSON、HTML或其他格式，这取决于服务器端的设置和客户端的需求。</p>
<h3 id="实现一个简单的Ajax请求"><a href="#实现一个简单的Ajax请求" class="headerlink" title="实现一个简单的Ajax请求"></a>实现一个简单的Ajax请求</h3><p>以下是一个使用XMLHttpRequest对象实现Ajax请求的示例。这个示例将向服务器发送一个GET请求，并处理服务器返回的响应。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个XMLHttpRequest对象</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 配置请求：设置请求类型（GET）、请求的URL以及是否异步（true表示异步）</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;https://api.example.com/data&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 定义当请求状态改变时要执行的函数</span></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 检查请求是否完成（readyState为4）以及是否成功（status为200）</span></span><br><span class="line">    <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="comment">// 解析服务器返回的JSON数据</span></span><br><span class="line">        <span class="keyword">var</span> responseData = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在这里处理返回的数据，例如更新网页内容</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(responseData);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理请求失败的情况</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;请求失败，状态码：&#x27;</span>, xhr.<span class="property">status</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 发送请求（对于GET请求，数据通常作为查询参数附加到URL上）</span></span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure>

<h3 id="使用Fetch-API实现Ajax请求"><a href="#使用Fetch-API实现Ajax请求" class="headerlink" title="使用Fetch API实现Ajax请求"></a>使用Fetch API实现Ajax请求</h3><p>Fetch API是现代浏览器中用于发起网络请求的另一种方式，它提供了一个更简洁、更强大的接口来处理HTTP请求和响应。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用fetch函数发起GET请求</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 检查响应是否成功（状态码在200-299之间）</span></span><br><span class="line">        <span class="keyword">if</span> (!response.<span class="property">ok</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;网络响应失败，状态码：&#x27;</span> + response.<span class="property">status</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回JSON格式的数据</span></span><br><span class="line">        <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里处理返回的数据，例如更新网页内容</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 处理请求过程中发生的错误</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;请求失败：&#x27;</span>, error);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><strong>跨域问题</strong>：如果请求的URL与当前页面的源不同（即跨域请求），则可能会遇到跨域资源共享（CORS）问题。服务器需要配置适当的CORS头部来允许跨域请求。</li>
<li><strong>安全性</strong>：确保与服务器通信时使用HTTPS协议，以保护数据在传输过程中的安全。</li>
<li><strong>错误处理</strong>：在处理网络请求时，始终要包含错误处理逻辑，以应对可能出现的网络问题、服务器错误等。</li>
<li><strong>浏览器兼容性</strong>：虽然现代浏览器都支持XMLHttpRequest和Fetch API，但在一些较旧的浏览器上可能需要使用polyfill或降级处理。</li>
</ol>

</div> 

<script>
    window.onload = detectors();
</script>
    <div class="post-footer">
    <div class="h-line-primary"></div>
    <nav class="post-nav">
        <div class="prev-item">
           
                <div class="icon arrow-left"></div>
                <div class="post-link">
                    <a href="/2024/10/12/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/">Prev</a>
                </div>
            
        </div>
        <div class="next-item">
            
                <div class="icon arrow-right"></div>
                <div class="post-link">
                  <a href="/2024/09/21/%E5%88%9B%E6%96%B0_%E9%97%AE%E9%A2%98_%E8%A7%A3%E5%86%B3/">Next</a>  
                </div>  
            
        </div>
    </nav>
</div>

    
      <div class="post-comment">

     

     
    
    

</div>
     
  
</article>
        </div>
      </div>
      
      <div class="footer">
    <div class="flex-container">
        <div class="footer-text">
            
            
            
                Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/zoeingwingkei/frame/">Frame</a>
                
        </div>
    </div>
</div>

    </div>

    
    

  </body>
</html>
