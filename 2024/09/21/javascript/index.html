<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="John Doe">







<title>javascript | Hexo</title>



    <link rel="icon" href="/favicon.ico">



<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=Roboto+Mono&display=swap');
</style>



    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    




    <!-- scripts list from _config.yml -->
    
    <script src="/js/menu.js"></script>
    










  <meta name="generator" content="Hexo 7.3.0"></head>
  <body>
    <div class="mask-border">
    </div>

    <div class="wrapper">

      <div class="header">
  <div class="flex-container">
    <div class="header-inner">
      <div class="site-brand-container">
        <a href="/">
          
            Frame.
          
        </a>
      </div>
      <div id="menu-btn" class="menu-btn" onclick="toggleMenu()">
        Menu
      </div>
      <nav class="site-nav">
        <ul class="menu-list">
          
            
              <li class="menu-item">
                <a href="/">Home</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/archives/">Archive</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/categories/gallery/">Gallery</a>
              </li> 
                   
          
          
        </ul>
      </nav>
    </div>
  </div>
</div>


      <div class="main">
        <div class="flex-container">
          <article id="post">

  
    <div class="post-head">
    <div class="post-info">
        <div class="tag-list">
            
        </div>
        <div class="post-title">
            
            
                javascript
            
            
        </div>
        <span class="post-date">
            Sep 21, 2024
        </span>
    </div>
    <div class="post-img">
        
            <div class="h-line-primary"></div>
              
    </div>
</div>
    <div class="post-content">
    <h2 id="（一）基础语法"><a href="#（一）基础语法" class="headerlink" title="（一）基础语法"></a>（一）基础语法</h2><h3 id="一-js定义"><a href="#一-js定义" class="headerlink" title="一.js定义"></a>一.js定义</h3><p><strong>定义</strong>：是一种运行在<strong>客户端（浏览器）</strong>的<strong>编程语言</strong>。</p>
<p>而html和css是<strong>标记语言</strong></p>
<p><strong>作用</strong>：</p>
<ol>
<li>网页特效</li>
<li>数据交互</li>
<li>表单验证</li>
<li>服务端编程（node.js）</li>
</ol>
<p><strong>组成</strong>：</p>
<p><strong>ECMAScript语言基础和Web APIs</strong></p>
<p>其中Web APIs又分为DOM和BOM，DOM文本对象模型，BOM浏览器对象模型。</p>
<p><strong>书写位置：</strong></p>
<ol>
<li><strong>内部js</strong>，通常放在html底部，<strong>写在body内部的最底部</strong>，目的是为了让页面先渲染再进行script渲染。 </li>
<li><strong>外部js</strong>,使用src引入，适用于代码比较多。</li>
<li>标签内部（<strong>行内js</strong>），一般在vue框架时使用，原生少。</li>
</ol>
<p><strong>输入和输出语法：</strong></p>
<p>什么是语法？</p>
<p><strong>语法</strong>就是人和计算机打交道的规则，是一种约定。</p>
<p>输出语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">document.write(&#x27;浏览器展示内容&#x27;)</span><br><span class="line">document.write(&#x27;&lt;h1&gt;我是标题&lt;/h1&gt;&#x27;)</span><br><span class="line">alert(&#x27;弹出框&#x27;)</span><br><span class="line">console.log(&#x27;控制台打印输出&#x27;)</span><br></pre></td></tr></table></figure>

<p>输入语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prompt(&#x27;请输入年龄：&#x27;)</span><br></pre></td></tr></table></figure>

<p><strong>字面量：</strong></p>
<p>字面量是<strong>在计算机中描述事&#x2F;物。</strong></p>
<p>比如：18 是数字字面量， ‘18’是字符串字面量</p>
<p>[]是数组字面量，{}是对象字面量。</p>
<h3 id="二-变量"><a href="#二-变量" class="headerlink" title="二.变量"></a>二.变量</h3><p><strong>定义</strong>：<strong>存储数据</strong>的<strong>容器</strong>。变量是个盒子。</p>
<p><strong>使用</strong>：</p>
<p>​	声明变量：声明关键字+变量名（标识符）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let name</span><br></pre></td></tr></table></figure>

<p>​	变量赋值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">age=18</span><br></pre></td></tr></table></figure>

<p>​	更新变量</p>
<p><strong>本质：</strong></p>
<p>变量组成规则：英文、数字、下划线、$、数字，但数字不能开头；</p>
<p>​							严格区分大小写。</p>
<h3 id="三-常量"><a href="#三-常量" class="headerlink" title="三.常量"></a>三.常量</h3><p>本质也是变量，代表用const声明的变量。</p>
<p>利用const声明，声明时必须初始化，一旦赋值无法改变（基本变量）。</p>
<h3 id="四-数据类型"><a href="#四-数据类型" class="headerlink" title="四.数据类型"></a>四.数据类型</h3><p>主要分为两大类：<strong>基本数据</strong>类型和<strong>引用数据</strong>类型。</p>
<p>基本数据类型(5)：number string boolean undefined null</p>
<p>引用数据类型(1)：object</p>
<p>js是一门<strong>弱数据</strong>类型的语言。</p>
<h4 id="number"><a href="#number" class="headerlink" title="number"></a>number</h4><p>里面比较特殊的是NaN,代表计算错误。</p>
<h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p>被‘’， “”， &#96;&#96;包裹的数据。</p>
<p>字符串拼接：+  或者 模版字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;pink&#x27;+&#x27;water&#x27;)</span><br><span class="line">console.log(&#x27;我今年&#x27;+age+&#x27;岁了 &#x27;)</span><br><span class="line">console.log(`我今年$&#123;age&#125;岁了`)</span><br></pre></td></tr></table></figure>

<h4 id="null"><a href="#null" class="headerlink" title="null"></a>null</h4><p>null代表的是<strong>未定义的对象</strong>，其实本质是没有放值的对象，应用场景是给为赋值的对象占位。</p>
<h4 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h4><p>代表声明了但未赋值的变量。</p>
<h4 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h4><p>为假的值：<strong>‘’  0 NaN undefined null false</strong></p>
<p>其余全为真。</p>
<h4 id="检测数据类型"><a href="#检测数据类型" class="headerlink" title="检测数据类型"></a>检测数据类型</h4><p><strong>typeof</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let num=10</span><br><span class="line">console.log(typeof num)//number</span><br></pre></td></tr></table></figure>

<h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><h5 id="字符串转数字："><a href="#字符串转数字：" class="headerlink" title="字符串转数字："></a>字符串转数字：</h5><ol>
<li>一元运算符<strong>正号</strong>【特别有用，一般表单输入的值都是字符串，可以用let data&#x3D;+prompt(‘请输入数字’)进行快速转换】</li>
<li>二元运算符减、乘、除自动转换</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let num =+string</span><br><span class="line">console.log(typeof num)//number</span><br><span class="line">let num =&#x27;1&#x27;-0</span><br><span class="line">console.log(typeof num)//1</span><br><span class="line">let num =&#x27;1&#x27;+0</span><br><span class="line">console.log(typeof num)//10</span><br></pre></td></tr></table></figure>

<h5 id="数字转字符串："><a href="#数字转字符串：" class="headerlink" title="数字转字符串："></a>数字转字符串：</h5><ol>
<li>二元运算符加号</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let num =&#x27;1&#x27;+0</span><br><span class="line">console.log(typeof num)//string</span><br></pre></td></tr></table></figure>

<h5 id="基础数据类型转换为对象："><a href="#基础数据类型转换为对象：" class="headerlink" title="基础数据类型转换为对象："></a>基础数据类型转换为对象：</h5><p>当调用基础属性类型的属性和方法时，js内部会隐式的把基础数据类型转换为对象，这样就可以调用对象的属性和方法了。如string.length,string.split()</p>
<p><strong>&#x3D;&#x3D;比较时：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true==1 //将true转换</span><br></pre></td></tr></table></figure>



<h4 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h4><ol>
<li>Number()</li>
<li>parseInt() 字符串转化为数字（只取前面的数）</li>
<li>parseFloat() 字符串转化为浮点数（只取前面的数）</li>
<li><img src="/../images/image-20240921223424263.png" alt="image-20240921223424263"></li>
</ol>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><h5 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h5><ul>
<li>push() pop()</li>
<li>unshift() shift()</li>
<li>sort() reverse()</li>
<li>splice(1,2,’newNum’)从第一个元素开始，删去两个值，在第一个元素后面加上newNum。<strong>直接修改</strong>原数组 【用很多】</li>
<li>split(‘*’) 用于<strong>字符串</strong>，将字符串分割开，返回一个<strong>新数组</strong>。</li>
<li>join(“*”)用于<strong>数组</strong>，将数组中的所有元素连接成一个字符串，并返回一个新的字符串。</li>
<li>map() 对每个元素进行操作，<strong>返回新数组</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let numbers = [1, 4, 9];  </span><br><span class="line">let doubled = numbers.map(function(num) &#123;  </span><br><span class="line">  return num * 2;  </span><br><span class="line">&#125;);  </span><br><span class="line">  </span><br><span class="line">console.log(doubled); // 输出: [2, 8, 18]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="for…in-for…of"><a href="#for…in-for…of" class="headerlink" title="for…in ,for…of:"></a>for…in ,for…of:</h5><p><strong>for…in用来遍历键，of用来遍历值。</strong></p>
<p>遍历数组：【直接】</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1, 2, 3, 4];  </span><br><span class="line">for (const key in arr) &#123;  </span><br><span class="line">  console.log(key); // 输出索引：0, 1, 2, 3  但是是字符串，很少用来遍历数组</span><br><span class="line">&#125;</span><br><span class="line">const arr = [1, 2, 3, 4];  </span><br><span class="line">for (const value of arr) &#123;  </span><br><span class="line">  console.log(value); // 输出数组元素：1, 2, 3, 4  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历对象：【in可直接遍历，of不可以】</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123; name: &#x27;Alice&#x27;, age: 30 &#125;;  </span><br><span class="line">for (const key in obj) &#123;  </span><br><span class="line">  console.log(key); // 输出属性名：name, age  </span><br><span class="line">  console.log(obj[key]); // 输出属性值：Alice, 30 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//将对象的键转换成数组来间接使用 for...of 遍历对象的值</span><br><span class="line">for(const value of Object.keys(obj))&#123;</span><br><span class="line">	console.log(obj[key]); // 输出属性值：Alice, 30  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="关于空数组的转换："><a href="#关于空数组的转换：" class="headerlink" title="关于空数组的转换："></a>关于空数组的转换：</h5><p><img src="/../images/image-20240921223440371.png" alt="image-20240921223440371"></p>
<h5 id="冒泡排序："><a href="#冒泡排序：" class="headerlink" title="冒泡排序："></a>冒泡排序：</h5><p><img src="/../images/image-20240921223518650.png" alt="image-20240921223518650"></p>
<h4 id="堆栈空间分配"><a href="#堆栈空间分配" class="headerlink" title="堆栈空间分配"></a>堆栈空间分配</h4><ul>
<li>栈：由操作系统自动分配释放存放函数的参数值、局部变量的值等。<strong>简单数据类型存放在栈里面。</strong></li>
<li>堆：存储复杂类型（对象），一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。<strong>引用数据类型存放在堆里面。</strong></li>
</ul>
<p>数据分配如图所示：</p>
<p><img src="/../images/image-20240921223532520.png" alt="image-20240921223532520"></p>
<p>​	<strong>总结</strong>：简单数据类型是把值直接存放在栈里面，而复杂数据类型是把<strong>引用地址存放在栈里面，真正的值放在堆里面，其变量名指向栈中的地址</strong>。</p>
<h4 id="空间分配训练题目"><a href="#空间分配训练题目" class="headerlink" title="空间分配训练题目"></a>空间分配训练题目</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let num1= 10</span><br><span class="line">let num2= num1</span><br><span class="line">num2=20</span><br><span class="line">console.log(num1)//10</span><br></pre></td></tr></table></figure>

<p><img src="/../images/image-20240921223540281.png" alt="image-20240921223540281"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let obj1=&#123;age:10&#125;</span><br><span class="line">let obj2=obj1</span><br><span class="line">obj2.age=20</span><br><span class="line">console.log(obj1)//&#123;age:20&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/image-20240921223550280.png" alt="image-20240921223550280"></p>
<h3 id="五-函数"><a href="#五-函数" class="headerlink" title="五.函数"></a>五.函数</h3><p>定义：执行特定任务的代码块。最大的作用在于复用。</p>
<p>分为<strong>具名函数</strong>和<strong>匿名函数</strong>。</p>
<h4 id="具名函数"><a href="#具名函数" class="headerlink" title="具名函数"></a>具名函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function getSum(num1,num2=0)&#123;</span><br><span class="line">//形参</span><br><span class="line">	document.write(num1+num2)</span><br><span class="line">&#125;</span><br><span class="line">getSum(10,20)</span><br><span class="line">//实参</span><br></pre></td></tr></table></figure>

<h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><p>定义：代码有效的范围，提高有用性，减少名字冲突。</p>
<h6 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h6><p>全局作用域：执行于整个script标签的内部。</p>
<p>局部作用域：作用于函数内部或块内部。</p>
<h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><p>使用方法：<strong>函数表达式</strong>和<strong>立即执行函数</strong></p>
<h5 id="函数表达式——防止函数提升"><a href="#函数表达式——防止函数提升" class="headerlink" title="函数表达式——防止函数提升"></a>函数表达式——防止函数提升</h5><p>必须先声明后调用。</p>
<p>将匿名函数赋值给变量，通过变量名称进行调用或者传递，我们将这个成为函数表达式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let fn=function()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>

<h5 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h5><p>作用：防止变量污染</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//写法一 (function()&#123;&#125;)()</span><br><span class="line">(function(x,y)&#123;</span><br><span class="line">	console.log(x+y)//块级作用域</span><br><span class="line">&#125;)(1,2);//必须加分号</span><br><span class="line"></span><br><span class="line">//写法二 (function()&#123;&#125;())</span><br><span class="line">(function(x,y)&#123;</span><br><span class="line">	console.log(x+y)</span><br><span class="line">&#125;(1,3));</span><br></pre></td></tr></table></figure>

<h5 id="变量访问原则"><a href="#变量访问原则" class="headerlink" title="变量访问原则"></a>变量访问原则</h5><p>先局部后全局 就近原则</p>
<h3 id="六-逻辑中断"><a href="#六-逻辑中断" class="headerlink" title="六.逻辑中断"></a>六.逻辑中断</h3><p><strong>||左边为true就中断</strong></p>
<p><strong>&amp;&amp;左边为false就中断</strong></p>
<p><strong>||输出第一个真值</strong>（顺序执行，遇真输出）</p>
<p><strong>&amp;&amp;输出最后一个真值</strong>（顺序执行，遇假输出，到最后就输出最后的）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let age=18</span><br><span class="line">false&amp;&amp;age++</span><br><span class="line">console.log(age)//18</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(11 &amp;&amp; 22)//22</span><br><span class="line">console.log(11 || 22)//11</span><br></pre></td></tr></table></figure>

<h3 id="七-对象"><a href="#七-对象" class="headerlink" title="七.对象"></a>七.对象</h3><p>无序的数据集合。</p>
<p>对象由<strong>属性和方法</strong>组成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let 对象名=&#123;</span><br><span class="line">	属性名：属性值,</span><br><span class="line">	方法名：函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h4><p>增加属性：obj.newKeys&#x3D;‘name’</p>
<p>查找属性：obj.age 或者 obj[‘age’]</p>
<p>删除属性：delete obj.age【了解，严格模式不允许】</p>
<h4 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h4><p>详情看数组的for…in 和for…of</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123; name: &#x27;Alice&#x27;, age: 30 &#125;;  </span><br><span class="line">for (const key in obj) &#123;  </span><br><span class="line">//key是字符串,所以不用加&quot;&quot;</span><br><span class="line">  console.log(key); // 输出属性名：name, age  </span><br><span class="line">  console.log(obj[key]); // 输出属性值：Alice, 30 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h4><p>js内部提供的对象，包括各种属性和方法给开发者调用。 </p>
<h5 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Math.ceil(1.1)向上取整</span><br><span class="line">Math.floor(1.1)向下取整</span><br><span class="line">Math.round(1.1)四舍五入</span><br><span class="line">Math.max(1,2,3,4,5)寻找最大值，不能放数组</span><br><span class="line">Math.min(1,2,3,4,5)寻找最小值，不能放数组</span><br><span class="line">Math.random()生成0-1之间的随机数（包括0不包括1 [0.1) ）</span><br></pre></td></tr></table></figure>

<p>生成一个0-10的随机数？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.floor(Math.random()*(10+1))</span><br></pre></td></tr></table></figure>

<p>生成一个5-10的随机数？**[记]**</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.floor(Math.random()*(5+1))+5</span><br></pre></td></tr></table></figure>

<h6 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h6><p><strong>选取随机数组：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr=[&#x27;red&#x27;,&#x27;yall&#x27;,&#x27;blue&#x27;]</span><br><span class="line">let random=Math.floor(Math.random()*arr.length)</span><br></pre></td></tr></table></figure>

<p><strong>返回随机颜色：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function getRandomColor(flag)&#123;</span><br><span class="line">	//返回十六进制形式</span><br><span class="line">	if(flag)&#123;</span><br><span class="line">		let str=&#x27;#&#x27;</span><br><span class="line">		let arr=[&#x27;0&#x27;,&#x27;1&#x27;,...&#x27;e&#x27;,&#x27;f&#x27;]</span><br><span class="line">		for(let i=0;i&lt;6;i++)&#123;</span><br><span class="line">			let index=Math.floor(Math.random()*arr.length)</span><br><span class="line">			str+=arr[index]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//返回rgb形式</span><br><span class="line">	else&#123;</span><br><span class="line">	let red=Math.floor(Math.random()*256)</span><br><span class="line">	let blue=Math.floor(Math.random()*256)</span><br><span class="line">	let yellow=Math.floor(Math.random()*256)</span><br><span class="line">		return `rgb($&#123;red&#125;,$&#123;blue&#125;,$&#123;yellow&#125;)`</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let color=getRandomColor(false)</span><br></pre></td></tr></table></figure>

<h2 id="（二）API篇"><a href="#（二）API篇" class="headerlink" title="（二）API篇"></a>（二）API篇</h2><p><strong>const 优先</strong>，有了变量先给const，发现改变再换成let。</p>
<h3 id="一-WebAPI"><a href="#一-WebAPI" class="headerlink" title="一.WebAPI"></a>一.WebAPI</h3><ul>
<li>作用：通过js去操作html和浏览器。</li>
<li>分类：<strong>DOM(文档对象模型)、BOM（浏览器对象模型）</strong></li>
</ul>
<p><img src="/../images/image-20240921223611503.png" alt="image-20240921223611503"></p>
<h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h4><p>**Document Object Model **  文档对象模型</p>
<p>DOM是<strong>浏览器</strong>提供的一套专门用来<strong>操作网页内容</strong>的功能。</p>
<p>作用：开发网页内容特效和实现用户交互。</p>
<h5 id="DOM树"><a href="#DOM树" class="headerlink" title="DOM树"></a>DOM树</h5><p>定义：将html文档以树状结构直观的表现出来，我们称之为<strong>文档树或DOM树</strong>。是一种<strong>描述网页关系</strong>的名词。</p>
<p>作用：文档树直观的<strong>体现了标签和标签之间的关系</strong>。</p>
<p><img src="/../images/image-20240921223623152.png" alt="image-20240921223623152"></p>
<h5 id="DOM对象"><a href="#DOM对象" class="headerlink" title="DOM对象"></a>DOM对象</h5><p>核心思想：把标签当做对象处理。</p>
<p>举例，<em>div</em>在<strong>html里叫做标签</strong>，而在<strong>js里面叫DOM对象</strong>。</p>
<p>获取DOM对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">document.querySelector(&quot;div&quot;)</span><br><span class="line">document.querySelector(&quot;ul li:first-child&quot;)</span><br><span class="line">div.style.color=&#x27;red&#x27;</span><br><span class="line"></span><br><span class="line">let lis=document.querySelectorAll(&quot;ul li&quot;)</span><br><span class="line">console.log(lis)//NodeList(3) [li,li,li]</span><br><span class="line">lis[0].style.color=&#x27;red&#x27;</span><br></pre></td></tr></table></figure>

<p>小补充：</p>
<ol>
<li>注意要加<strong>引号</strong>，否则当变量处理。</li>
<li>当获取<strong>单个</strong>元素时，可以直接对元素属性进行修改。</li>
<li>当获取<strong>多个</strong>元素时，获取到一个<strong>伪数组</strong>，尽管有长度和元素，但无法使用数组的方法，也<strong>无法直接</strong>对元素的属性进行修改（但可以通过<strong>遍历</strong>修改）。</li>
</ol>
<h5 id="操作元素内容"><a href="#操作元素内容" class="headerlink" title="操作元素内容"></a>操作元素内容</h5><ul>
<li>innerText纯文本，不解析标签</li>
<li>innerHTML解析标签</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let box=document.querySelector(&quot;div&quot;)</span><br><span class="line">box.innerText=&quot;我是新的文字内容&quot;</span><br><span class="line"></span><br><span class="line">box.innerHTML=&quot;&lt;strong&gt;解析标签，加粗&lt;/strong&gt;&quot;</span><br></pre></td></tr></table></figure>



<h5 id="操作元素属性"><a href="#操作元素属性" class="headerlink" title="操作元素属性"></a>操作元素属性</h5><ul>
<li>修改元素常用属性</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let img =document.querySelector(&quot;img&quot;)</span><br><span class="line">img.src=&quot;./images/1.png&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改元素样式属性</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//1</span><br><span class="line">img.style.width=&quot;1000px&quot;</span><br><span class="line"></span><br><span class="line">//2</span><br><span class="line">img.className=&#x27;imgaes&#x27;//修改类名，一句话搞定，很方便，但类名容易覆盖，不推荐</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//3</span><br><span class="line">//推荐</span><br><span class="line">img.classList.add(&#x27;active&#x27;)//追加类名，不用担心覆盖，推荐,这是对象的属性【存放对象】的方法</span><br><span class="line">img.classList.remove(&#x27;box&#x27;)//删除类名</span><br><span class="line">img.classList.toggle(&#x27;active&#x27;)//切换类，有就删掉，没有就加上！！！！！！有用！！！！！</span><br></pre></td></tr></table></figure>



<h5 id="操作表单元素属性"><a href="#操作表单元素属性" class="headerlink" title="操作表单元素属性"></a>操作表单元素属性</h5><ul>
<li>获取表单值   ——不能用innerHTML!</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; value=&quot;电脑&quot;&gt;</span><br><span class="line"></span><br><span class="line">let input =document.querySelector(&#x27;input&#x27;)</span><br><span class="line">console.log(input.value)</span><br><span class="line">input.type=&quot;password&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改表单状态  ——接受布尔值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input.checked=false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">input.disabled=true</span><br></pre></td></tr></table></figure>



<h5 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h5><p><strong>H5</strong>新出，规定以<strong>data-xxx</strong>开头的都是自定义属性。</p>
<p>标签中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div data-id=&quot;1&quot; data-spm=&#x27;不知道&#x27;&gt;1&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>js中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let div = document.querySelector(&#x27;div&#x27;)</span><br><span class="line">//dataset可以获取全部自定义属性</span><br><span class="line">div.dataset.id=&#x27;2&#x27;</span><br></pre></td></tr></table></figure>



<h5 id="定时器——间歇函数"><a href="#定时器——间歇函数" class="headerlink" title="定时器——间歇函数"></a>定时器——间歇函数</h5><ul>
<li>开启定时器 ——过了多少执行函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">*setInterval(函数，间隔时间【ms】)</span><br><span class="line"></span><br><span class="line">//写法一</span><br><span class="line">let timer1=setInterval(()=&gt;&#123;</span><br><span class="line">	console.log(&#x27;一秒执行一次&#x27;)</span><br><span class="line">&#125;,1000)</span><br><span class="line"></span><br><span class="line">//写法二,注意回调函数不加小括号，不然就是立即执行</span><br><span class="line">let timer2=function fn()&#123;</span><br><span class="line">	console.log(&#x27;一秒执行一次&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">setInterval(fn,1000)</span><br></pre></td></tr></table></figure>

<ul>
<li>销毁定时器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clearInterval(timer1)</span><br></pre></td></tr></table></figure>

<ul>
<li>应用：手写的轮播图</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//轮播图的结构有div p ul li这里就不写了</span><br><span class="line">let data=[&#123;</span><br><span class="line">	title:&#x27;xxxx&#x27;,url:&#x27;xxx&#x27;</span><br><span class="line">&#125;]</span><br><span class="line">let p=document.querySelector(&quot;p&quot;)</span><br><span class="line">let img=document.querySelector(&quot;img&quot;)</span><br><span class="line">let i=0</span><br><span class="line">let timer=setInterVal(</span><br><span class="line">	function()&#123;</span><br><span class="line">		i++</span><br><span class="line">		if(i&gt;=data.length)&#123;</span><br><span class="line">			i=0</span><br><span class="line">		&#125;</span><br><span class="line">		p.innerHTML=data[i].title</span><br><span class="line">		img.src=data[i].url</span><br><span class="line">		let preActive=document.querySelector(&quot;ul .active&quot;)</span><br><span class="line">		preActive.classList.remove(&#x27;active&#x27;)</span><br><span class="line">		let nowActive=document.querySelector(&quot;ul li:nth-child($&#123;i+1&#125;)&quot;).classList.add(&#x27;active&#x27;)</span><br><span class="line">		//其实这里用两个toggle也是可以解决的，注意获取活跃元素可以直接通过类名，而不是一个个遍历查找活跃元素</span><br><span class="line">	&#125;，1000</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h4><p><strong>事件</strong>：在编程时系统内发生的<strong>动作</strong>或者发生的事情。</p>
<p>​	例如，用户点击了某个按钮。</p>
<p><strong>事件监听</strong>：让<strong>程序检测是否有事件产生</strong>，一旦有事件触发，就立刻调用一个函数<strong>做出响应</strong>，也称<strong>注册事件</strong>。例如点击按钮后，发送请求。</p>
<p>相同：都触发事件。</p>
<p>区别：是否有<strong>响应</strong>发生。</p>
<p><strong>事件监听三要素</strong>：</p>
<ol>
<li>事件源：即事件监听发生的DOM元素。（谁）</li>
<li>事件类型：事件触发的方式，如click、mouseover等等。（方式）</li>
<li>事件调用的函数：事件触发进行响应的函数。（触发什么）</li>
</ol>
<h5 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h5><ul>
<li><p>鼠标事件</p>
<ul>
<li>click</li>
<li>mouseenter</li>
<li>mouseleave</li>
</ul>
</li>
<li><p>焦点事件</p>
<ul>
<li>focus</li>
<li>blur</li>
</ul>
</li>
<li><p>键盘事件</p>
<ul>
<li>keydown</li>
<li>keyup</li>
</ul>
</li>
<li><p>文本事件</p>
<ul>
<li>input</li>
</ul>
</li>
</ul>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xx.addEventListener(&#x27;click&#x27;,function()&#123;&#125;)</span><br><span class="line">//注意这里click是字符串，没有字符串当变量使用，但这里没有变量！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//变量使用</span><br><span class="line">let event=&quot;click&quot;</span><br><span class="line">xx.addEventListener(event,function()&#123;&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h5><p>事件对象：<strong>存储了事件触发信息</strong>的对象。</p>
<p>使用场景：判断用户按下哪个键和哪个元素。</p>
<p>如何获取：在<strong>事件绑定的回调函数</strong>的<strong>第一个参数</strong>就是事件对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">元素.addEventListener(&#x27;click&#x27;,function(e)&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>部分常用属性：</p>
<ul>
<li>type —事件触发的类型</li>
<li>clientX,clientY  —获取光标相对<strong>浏览器窗口</strong>的位置</li>
<li>offsetX,offsetY —获取光标相对于<strong>当前Dom元素左上角</strong>的位置</li>
<li>key —键盘按键</li>
</ul>
<h5 id="环境对象"><a href="#环境对象" class="headerlink" title="环境对象"></a>环境对象</h5><p>每个函数内部特殊的<strong>变量this</strong>，他代表着当前<strong>函数运行时所处的环境。</strong></p>
<p><strong>普通函数this</strong>指向的是<strong>window</strong>。</p>
<p><strong>谁调用，this就指向谁。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function() fn()&#123;</span><br><span class="line">	console.log(this)</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line">//其实内部是</span><br><span class="line">window.fn()</span><br></pre></td></tr></table></figure>

<p>应用：不方便知道点击了数组的哪个DOM对象，用this可以轻易获取对象。</p>
<h5 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h5><p>当把函数A<strong>作为参数</strong>传递给函数B时，我们称A为回调函数。</p>
<p>例如定时器里的函数参数，事件监听的函数参数。都<strong>不会立即执行</strong>，根据条件进行调用。</p>
<p>应用场景：</p>
<p>当复选框全选时，自动勾选全选框。</p>
<p>以前：用for循环一个个遍历是否选中。</p>
<p>现在：利用css属性input:checked</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const inputs=document.querySelectorAll(&#x27;.ck&#x27;)</span><br><span class="line">const quanxuan=document.querySelectorAll(&#x27;.quan&#x27;)</span><br><span class="line">for(let i=0;i&lt;inputs.length;i++)&#123;</span><br><span class="line">	inputs.addEventListener&#123;						if(document.querySelector(&quot;.ck:checked&quot;).length===inputs.length)</span><br><span class="line">	&#123;</span><br><span class="line">	quanxuan.checked=true</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">	quanxuan.checked=false</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//或者,特别简洁！！！</span><br><span class="line">	quanxuan.checked=document.querySelector(&quot;.ck:checked&quot;).length==inputs.length</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二-事件流"><a href="#二-事件流" class="headerlink" title="二.事件流"></a>二.事件流</h3><h4 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h4><p>定义：事件<strong>完整执行过程</strong>中的<strong>流动路径</strong>。</p>
<p>阶段：</p>
<ol>
<li>捕获阶段</li>
<li>冒泡阶段</li>
</ol>
<p>工作中大多数利用<strong>冒泡</strong>阶段。</p>
<p><strong>事件冒泡</strong>：当触发子元素的某事件时，该祖先元素<strong>若绑定了相同的事件</strong>，那么这些事件也会<strong>依次触发</strong>。这一过程称为冒泡。从下到上。</p>
<p><strong>阻止冒泡</strong>： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">事件对象.stopPropagation()</span><br></pre></td></tr></table></figure>

<h5 id="阻止默认行为："><a href="#阻止默认行为：" class="headerlink" title="阻止默认行为："></a>阻止默认行为：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">事件对象.PreventDefault()</span><br></pre></td></tr></table></figure>



<h4 id="事件解绑"><a href="#事件解绑" class="headerlink" title="事件解绑"></a>事件解绑</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const btn=document.querySelectorAll(&#x27;.ck&#x27;)</span><br><span class="line">//法一</span><br><span class="line">btn.addEventListener(&quot;click&quot;,function()&#123;</span><br><span class="line">	btn.click=null</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//法二 注意匿名函数无法被解绑 </span><br><span class="line">let fn=function()&#123;</span><br><span class="line">	btn.click=null</span><br><span class="line">&#125;</span><br><span class="line">btn.addEventListener(&quot;click&quot;,fn)</span><br><span class="line">btn.removeEventListener(&quot;click&quot;,fn)</span><br></pre></td></tr></table></figure>

<p><img src="/../images/image-20240921223650760.png" alt="image-20240921223650760"></p>
<p>总结：</p>
<ol>
<li><strong>绑定事件数量不同</strong>。传统的同一对象只能绑定一个事件，而事件监听注册可以绑定多个事件；</li>
<li><strong>执行阶段不同</strong>。传统的都只在冒泡阶段执行，而事件监听注册可以通过第三个参数确定是在那阶段执行；</li>
<li><strong>解绑方式不同</strong>。传统的用null，事件监听注册使用btn.removeEventListener(“click”,fn)解绑。</li>
</ol>
<h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><p>定义：是利用<strong>事件流</strong>的特征解决一些开发需求的知识技巧。</p>
<p>优点：减少注册次数，提高程序性能。</p>
<p>原理：利用<strong>事件冒泡</strong>绑定事件。委托给父元素。</p>
<p><strong>真正触发</strong>的元素：<strong>e.target</strong></p>
<p><strong>需求</strong>：点击li，使对应的li文字变为红色。只有li的时候执行，其他标签不执行。  若有需要<strong>获得索引的</strong>场景，用<strong>自定义标签</strong>。（很有用）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">	&lt;li data-id=&quot;0&quot;&gt;&lt;/li&gt;</span><br><span class="line">	&lt;li data-id=&quot;1&quot;&gt;&lt;/li&gt;</span><br><span class="line">	&lt;li data-id=&quot;2&quot;&gt;&lt;/li&gt;</span><br><span class="line">	&lt;li data-id=&quot;3&quot;&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ul.addEventListener(&#x27;click&#x27;,function(e)&#123;</span><br><span class="line">	e.target.tagName===&quot;LI&quot;&amp;&amp;e.target.style.color=&quot;red&quot;</span><br><span class="line">	//若有需要获得索引的场景，用自定义标签</span><br><span class="line">	let index=+e.target.dataset</span><br><span class="line">	//转为数字型</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="三-页面加载事件"><a href="#三-页面加载事件" class="headerlink" title="三.页面加载事件"></a>三.页面加载事件</h3><h4 id="页面加载事件"><a href="#页面加载事件" class="headerlink" title="页面加载事件"></a>页面加载事件</h4><p>load：等外部资源（图片、视频）全部加载完毕时加载js代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&quot;load&quot;,function&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>DOMContentLoaded：等待HTML文件的DOM节点全部加载完再执行。（当网速慢，图片虽然开始加载但没完全加载完毕）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&quot;DOMContentLoaded&quot;,function&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="页面滚动事件"><a href="#页面滚动事件" class="headerlink" title="页面滚动事件"></a>页面滚动事件</h4><p>scroll：一滚动就会触发。</p>
<p>场景：这里想让页面滑动到一定位置，展示div,其他情况则消失。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&quot;scroll&quot;,function&#123;</span><br><span class="line">//document.documentElement是获取html元素的方式</span><br><span class="line">	const n=document.documentElement.scrollTop</span><br><span class="line">	n&gt;=button.offsetTop?div.style.display=&quot;block&quot;:div.style.display=&quot;none&quot;</span><br><span class="line">	//人外有人山外有山，老师写的是</span><br><span class="line">	div.style.display=n&gt;=button.offsetTop?&#x27;block&#x27;:&#x27;none&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>应用</strong>：页面滚动到某个地方做对应事情。</p>
<p>属性：<strong>scrollTop scrollLeft</strong> ——获取被卷去的长度。可读取可修改，不带单位。</p>
<p><img src="/../images/image-20240921223705578.png" alt="image-20240921223705578"></p>
<h4 id="页面尺寸事件"><a href="#页面尺寸事件" class="headerlink" title="页面尺寸事件"></a>页面尺寸事件</h4><p><strong>resize</strong>:屏幕尺寸变化（响应式的原理）</p>
<p><strong>clientWidth、clientHeight</strong> 获取<strong>不包括边框</strong>的盒子长宽。</p>
<p><strong>offsetWidth、offsetHeight</strong> <strong>包含</strong>边框的盒子长宽。</p>
<p><strong>offsetLeft、offsetTop</strong> 盒子距离元素的长度。得到的位置以<strong>带有定位的父级</strong>为准，如果没有则以<strong>文档左上角</strong>为准。</p>
<p>场景：导航栏添加点击滑动效果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const ul =documenet.querySeletor(&quot;.tabs-list&quot;)</span><br><span class="line">const line =documenet.querySeletor(&quot;.line&quot;)</span><br><span class="line">ul.addEventListener(&quot;click&quot;,function(e)&#123;</span><br><span class="line">	if(e.target.tagName===&quot;A&quot;)&#123;</span><br><span class="line">		line.style.transform=`translateX($&#123;e.target.offsetLeft&#125;px)`</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>element.getBoundingCLientRect() 返回元素的大小以及相对于视口的位置</p>
<p>总结：</p>
<p><img src="/../images/image-20240921223714445.png" alt="image-20240921223714445"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//让页面滑动添加过渡效果，更平滑</span><br><span class="line">html&#123;</span><br><span class="line">	scroll-behavior:smooth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>属性选择器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//js</span><br><span class="line">document.querySelector(&quot;input[type=password]&quot;)</span><br><span class="line"></span><br><span class="line">//css</span><br><span class="line">in[value]&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四-日期对象"><a href="#四-日期对象" class="headerlink" title="四.日期对象"></a>四.日期对象</h3><h4 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const date=new Date()</span><br></pre></td></tr></table></figure>

<h4 id="日期对象方法"><a href="#日期对象方法" class="headerlink" title="日期对象方法"></a>日期对象方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const date=new Date()</span><br><span class="line">date.getFullYear()</span><br><span class="line">date.getMonth()+1 //0~11</span><br><span class="line">date.getDay() </span><br><span class="line">date.toLocalString() // 2022/4/1 09:41:44</span><br></pre></td></tr></table></figure>

<h5 id="获取指定格式时间"><a href="#获取指定格式时间" class="headerlink" title="获取指定格式时间"></a><img src="/../images/image-20240921223729833.png" alt="image-20240921223729833">获取指定格式时间</h5><p>  <strong>2024-04-04 08:08</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const date=new Data()</span><br><span class="line">const year=date.getFullYear()</span><br><span class="line">const month =date.getMonth()+1</span><br><span class="line">const date=date.getDate()=</span><br><span class="line">const hour=date.getHours()</span><br><span class="line">const minite=date.getMinies()</span><br><span class="line"></span><br><span class="line">month=month&gt;10?month:&#x27;0&#x27;+month</span><br><span class="line">date=date&gt;10?date:&#x27;0&#x27;+date</span><br><span class="line">hour=hour&gt;10?hour:&#x27;0&#x27;+hour</span><br><span class="line">minite=minite&gt;10?minite:&#x27;0&#x27;+minite</span><br><span class="line"></span><br><span class="line">let time=`$&#123;year&#125;-$&#123;month&#125;-$&#123;date&#125; $&#123;hour&#125;:$&#123;minite&#125;`</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h4><p>定义：1970-01-01 00:00起到现在的<strong>毫秒</strong>数。   </p>
<h5 id="获取时间戳："><a href="#获取时间戳：" class="headerlink" title="获取时间戳："></a><strong>获取时间戳</strong>：</h5><ul>
<li>date.getTime()   ——可以返回指定时间戳 </li>
<li><strong>+new Date()</strong>  ——可以返回指定时间戳</li>
<li>Date.now() ——只能返回当前时间戳</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const date=new Date()</span><br><span class="line">date.getTime()</span><br><span class="line"></span><br><span class="line">+new Date()</span><br><span class="line"></span><br><span class="line">Date.now()</span><br></pre></td></tr></table></figure>

<h5 id="倒计时案例"><a href="#倒计时案例" class="headerlink" title="倒计时案例"></a><strong>倒计时案例</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">getCountTime()</span><br><span class="line">function getCountTime()&#123;</span><br><span class="line">const now=+new Date()</span><br><span class="line">const last=+new Date(&#x27;2022-5-1 18:30:00&#x27;)</span><br><span class="line">//记得转换为秒</span><br><span class="line">const count=(last-now)/1000</span><br><span class="line">//套公式</span><br><span class="line">let s=parseInt(count%60)</span><br><span class="line">let m=parseInt(count/60%60)</span><br><span class="line">let h=parseInt(count/60/60%24)</span><br><span class="line">let d=parseInt(count/60/60/24)</span><br><span class="line">//对页面元素的操作...</span><br><span class="line">&#125;</span><br><span class="line">//开启定时器</span><br><span class="line">setInterval(getCountTime,1000)</span><br></pre></td></tr></table></figure>

<h3 id="五-节点操作"><a href="#五-节点操作" class="headerlink" title="五.节点操作"></a>五.节点操作</h3><h4 id="DOM节点"><a href="#DOM节点" class="headerlink" title="DOM节点"></a>DOM节点</h4><p>定义：<strong>DOM树中每一个内容</strong>称之为节点。</p>
<p>节点类型：</p>
<ul>
<li><strong>元素节点</strong>  ——如html、div</li>
<li>文本节点  ——所有的文本</li>
<li>属性节点  ——所有的属性 如herf</li>
<li>其他</li>
</ul>
<h4 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h4><p>利用亲戚关系查找对象。</p>
<p>获取父节点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xx.parentNode </span><br></pre></td></tr></table></figure>

<p>获取所有子节点：  获取到伪数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx.children</span><br></pre></td></tr></table></figure>

<p>获取兄弟节点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xxx.nextElementSibling</span><br><span class="line">xxx.previousElementSibling</span><br></pre></td></tr></table></figure>

<h4 id="增加节点"><a href="#增加节点" class="headerlink" title="增加节点"></a>增加节点</h4><p>步骤：</p>
<ol>
<li>创建节点</li>
<li>追加节点</li>
</ol>
<h5 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const div=document.createElement(&#x27;div&#x27;)</span><br></pre></td></tr></table></figure>

<h5 id="追加节点"><a href="#追加节点" class="headerlink" title="追加节点"></a>追加节点</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//插入到父元素的最后一个元素</span><br><span class="line">父元素.appendChild(div)</span><br><span class="line">//插入到某个子元素的前面</span><br><span class="line">父元素.insertBefore(要插入的元素，在哪个元素前面)</span><br><span class="line">ul.insertBefore(li，ul.children[0])</span><br></pre></td></tr></table></figure>

<h4 id="克隆节点"><a href="#克隆节点" class="headerlink" title="克隆节点"></a>克隆节点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">要克隆的元素.cloneNode(true)</span><br></pre></td></tr></table></figure>

<h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><p>必须通过父元素删除。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父元素.removeChild(子元素)</span><br><span class="line">父元素.removeChild(ul.children[0])</span><br></pre></td></tr></table></figure>

<p>删除节点和隐藏节点（display:none）是有区别的：隐藏节点还是存在的，但是删除，则从html中删除节点。</p>
<h3 id="六-M端事件"><a href="#六-M端事件" class="headerlink" title="六.M端事件"></a>六.M端事件</h3><p><strong>M端即移动端，P端即电脑端。</strong></p>
<p>触屏事件touch：</p>
<ul>
<li>touchstart</li>
<li>touchend</li>
<li>touchmove</li>
</ul>
<p><strong>swiper</strong>插件很好用。</p>
<h3 id="——以上都为DOM事件。"><a href="#——以上都为DOM事件。" class="headerlink" title="——以上都为DOM事件。"></a>——以上都为DOM事件。</h3><h3 id="七-Window对象"><a href="#七-Window对象" class="headerlink" title="七.Window对象"></a>七.Window对象</h3><h4 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h4><p>浏览器对象模型</p>
<p><img src="/../images/image-20240921223745225.png" alt="image-20240921223745225"></p>
<h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><ul>
<li>延时函数   ——只执行一次</li>
<li>间歇函数   ——每隔一段时间执行一次，除非手动清除</li>
</ul>
<h4 id="JS执行机制"><a href="#JS执行机制" class="headerlink" title="JS执行机制"></a>JS执行机制</h4><h5 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h5><p>浏览器有<strong>两个引擎</strong>，一个是<strong>渲染引擎</strong>（解析html和Css）,一个是<strong>Js解析器</strong>（如谷歌的V8,专门解析js）。</p>
<p>Js语言一大特点是<strong>单线程</strong>，意味着所有任务需要排队，执行完一个任务才能执行后一个任务。这样所导致的<strong>问题</strong>就是<strong>js若执行的时间过长，那么会导致页面不连贯</strong>。</p>
<p>为解决这个问题，<strong>H5</strong>提出web Worker标准，<strong>允许js脚本创建多个线程</strong>，于是js中出现了<strong>同步</strong>和<strong>异步</strong>。</p>
<h5 id="同步任务"><a href="#同步任务" class="headerlink" title="同步任务"></a>同步任务</h5><p>同步任务都在主线程上执行，形成一个执行栈。</p>
<h5 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h5><p>js的异步是<strong>通过回调函数</strong>实现的。</p>
<p>一般而言，异步任务有以下三种类型：</p>
<ol>
<li>普通事件，如click</li>
<li>资源加载，如load</li>
<li>定时器</li>
</ol>
<p>异步任务相关添加到<strong>任务队列</strong>中。</p>
<h5 id="Js执行机制"><a href="#Js执行机制" class="headerlink" title="Js执行机制"></a>Js执行机制</h5><p>事件循环：</p>
<p>首先，会把所有的<strong>同步任务放入执行栈</strong>，<strong>异步任务放入任务队列中</strong>；完成了执行栈后，系统会按次序读取任务队列中的异步任务，于是被<strong>读取的异步任务结束等待状态，进入执行栈，开始执行</strong>。</p>
<p><img src="/../images/image-20240921223755096.png" alt="image-20240921223755096"></p>
<p>完整流程：当执行任务时，主线程若发现有异步任务，会把<strong>异步任务交给浏览器处理</strong>，每当异步任务执行完毕，推入任务队列中（<strong>谁先执行完毕，谁就先推入任务队列中</strong>）。而主线程执行完毕后，会查询任务队列，<strong>依次取出任务</strong>，<strong>推入主线程</strong>处理，重复该动作。</p>
<p>第一个谁先执行完成谁先推入，其实举例就是2000的定时器会比5000的定期器先执行，无论位置。</p>
<p>第二个依次取出任务，就是按已经排好序的来了。</p>
<h4 id="localtion对象"><a href="#localtion对象" class="headerlink" title="localtion对象"></a>localtion对象</h4><p>使用场景：</p>
<p>href 无需点击，自动跳转页面</p>
<p>search 获取url提交的表单的信息（问号后面的内容）</p>
<p>hash 获取url井号后面的内容</p>
<p>reload 刷新页面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location.href=&quot;http:......cn&quot;</span><br></pre></td></tr></table></figure>

<h4 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h4><p>判断当前浏览器信息（是移动端还是PC端），自动跳转哪个页面。</p>
<h4 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h4><p>浏览器后退前进按钮的实现。</p>
<p>方法：</p>
<ul>
<li>back()</li>
<li>go()  &#x2F;&#x2F; 可传参数-1 2</li>
<li>forward()</li>
</ul>
<h3 id="八-本地存储"><a href="#八-本地存储" class="headerlink" title="八.本地存储"></a>八.本地存储</h3><p>H5提出。</p>
<ol>
<li>数据存储在用户浏览器中</li>
<li>读取方便，甚至可以页面刷新不丢失数据</li>
<li>容量较大，sessionStorage和localStorage约<strong>5M</strong></li>
</ol>
<p>特性：</p>
<ol>
<li>可以<strong>多窗口共享</strong>（同一浏览器可以共享）</li>
<li>以键值对的形式存储使用</li>
</ol>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//增删改查</span><br><span class="line">localStorage.setItem(&#x27;name&#x27;,&#x27;toto&#x27;)// 若有这个键，直接修改值</span><br><span class="line">localStorage.getItem(&#x27;name&#x27;)</span><br><span class="line">localStorage.removeItem(&#x27;name&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>存储复杂对象数据：</strong></p>
<p>本地存储里只能存普通数据类型。</p>
<p>需要将复杂数据类型转换为<strong>JSON字符串类型</strong>，再存储到本地。</p>
<p><strong>stringify 串化  parse 解析</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(&#x27;obj&#x27;,JSON.stringify(obj))</span><br><span class="line">let obj = JSON.parse(localStorage.getItem(&#x27;obj&#x27;))</span><br></pre></td></tr></table></figure>

<p><strong>JSON字符串和普通字符串到底有什么区别？</strong></p>
<p><strong>JSON字符串</strong>：符合JSON格式要求的字符串，具有明确的结构，可以表示复杂的数据对象，包括嵌套对象和数组。JSON对象由大括号（{}）包围，包含一系列由逗号分隔的键值对，其中键是字符串，值可以是字符串、数字、布尔值、null、对象或数组。JSON数组由方括号（[]）包围，包含一系列由逗号分隔的值。<strong>属性和值有引号</strong>，里面统一是<strong>双引号</strong>。</p>
<p>而普通字符串没有明确的结构，不能区分复杂数据类型。</p>
<h5 id="字符串拼接新方式"><a href="#字符串拼接新方式" class="headerlink" title="字符串拼接新方式"></a>字符串拼接新方式</h5><p>map 可以遍历数组处理数据，并且<strong>返回新的数组</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const arr=[&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;green&#x27;]</span><br><span class="line">const newArr=arr.map(function(ele,index)&#123;</span><br><span class="line">	return ele+&quot;颜色&quot;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">// newArr=[&#x27;red颜色&#x27;,&#x27;yellow颜色&#x27;,&#x27;green颜色&#x27;]</span><br></pre></td></tr></table></figure>

<p>join 用于把数组的元素拼接为一个字符串</p>
<p>split  把字符串转换为数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const string=arr.join(&#x27;*&#x27;)</span><br><span class="line">//red*yellow*green</span><br></pre></td></tr></table></figure>

<h3 id="九-正则表达式"><a href="#九-正则表达式" class="headerlink" title="九.正则表达式"></a>九.正则表达式</h3><h4 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h4><p>用于匹配字符串中字符组合的模式。</p>
<p>作用 ：</p>
<ol>
<li>验证表单</li>
<li>过滤敏感词</li>
<li>字符串中提取我么想要的部分</li>
</ol>
<p>使用：</p>
<ol>
<li>定义规则</li>
<li>是否匹配</li>
</ol>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const str=&quot;我爱前端。我爱前端？&quot;</span><br><span class="line">const reg =/前端/</span><br><span class="line">reg.test(str) //true</span><br><span class="line"></span><br><span class="line">reg.exec(str)//返回数组&#123;[&#x27;前端&#x27;,index:2,input:...]</span><br></pre></td></tr></table></figure>

<h4 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h4><p>特殊字符，如a-z包含abcde…，提高了灵活性。</p>
<h5 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h5><ul>
<li>边界符</li>
<li>量词</li>
<li>字符类</li>
</ul>
<p>边界符：提示位置，必须以什么开头，什么结尾。</p>
<p><img src="/../images/image-20240922161019492.png" alt="image-20240922161019492"></p>
<p>量词：表示重复。</p>
<p><img src="/../images/image-20240922161140404.png" alt="image-20240922161140404"></p>
<p>字符类：如简化\d表示0~9。</p>
<p><img src="/../images/image-20240922165534263.png" alt="image-20240922165534263"></p>
<h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p>修饰符约束正则执行的某些细节行为，如是否区分大小写，是否支持多行匹配等。</p>
<p><img src="/../images/image-20240922165902099.png" alt="image-20240922165902099"></p>
<h2 id="（三）JS进阶"><a href="#（三）JS进阶" class="headerlink" title="（三）JS进阶"></a>（三）JS进阶</h2><h4 id="一-作用域"><a href="#一-作用域" class="headerlink" title="一.作用域"></a>一.作用域</h4><p>作用域规定了变量能够访问的范围。</p>
<h5 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h5><ul>
<li>函数作用域</li>
<li>块级作用域</li>
</ul>
<h6 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h6><p>函数内部。</p>
<h6 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h6><ol>
<li><strong>let和const</strong>声明的常量<strong>会产生块级作用域</strong>。</li>
<li><strong>var</strong>声明的常量<strong>不会</strong>产生。</li>
<li>不同代码块之间的常量无法互相访问。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(var i=0;i&lt;=3;i++)&#123;&#125;</span><br><span class="line">console.log(i)//4</span><br><span class="line">//这里其实就是忽略块了，直接提升到上一级（即	全局）</span><br><span class="line"></span><br><span class="line">for(let i=0;i&lt;=3;i++)&#123;&#125;</span><br><span class="line">console.log(i)//undefined</span><br></pre></td></tr></table></figure>

<h5 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h5><script>标签和js文件的最外部一层，其他作用域都可以访问全局作用域。

1. 为window对象动态添加的属性默认也是全局的，但不推荐！！
2. 函数中没有声明关键字的变量也是全局的，但也不推荐！！
3. 少使用声明的全局变量，防止全局变量污染

##### 作用域链

**本质**就是底层的**变量查找机制**。

过程：优先查找最近的，若当前作用域没有，依次向上一级作用域查找。【理解为冒泡】

#### 二.垃圾回收机制

![image-20240922173151774](../images/image-20240922173151774.png)

##### 算法说明

![image-20240922173418020](../images/image-20240922173418020.png)

###### 引用计数法

若引用次数为0，那么该数据就是不再使用的，浏览器会进行回收。

基本不使用了。

使用方法就是把变量赋值为null，使指向数据的数量减少。

![image-20240922173446278](../images/image-20240922173446278.png)

缺陷

![image-20240922173710749](../images/image-20240922173710749.png)

###### 标记计数法

改善：将不再使用的对象定义为**无法到达的对象**。

过程：

1. 从根部（js中的全局对象）出发，扫描能够到达的对象。
2. 无法从根部到达的对象被标记为不再使用，稍后进行回收。

#### 三.闭包

含义：**闭包=内层函数+外层函数的变量**

即内层函数利用了外层函数的变量。

eg:

![image-20240923160754078](../images/image-20240923160754078.png)

**常用格式**：

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	const outer=function()&#123;</span><br><span class="line">		let a=10;</span><br><span class="line">		function fn()&#123;</span><br><span class="line">			console.log(a)</span><br><span class="line">		&#125;</span><br><span class="line">		return fn //封装思想，方便他人调用</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	outer()() // outer()===fn===funciton fn()&#123;&#125;</span><br><span class="line">	//涨芝士了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//多打！！！！！！！！</span><br><span class="line">const outer=function()&#123;</span><br><span class="line">	let a=10;</span><br><span class="line">	function fn()&#123;</span><br><span class="line">		console.log(a)</span><br><span class="line">	&#125;</span><br><span class="line">	return fn</span><br><span class="line">&#125;</span><br><span class="line">outer()();</span><br></pre></td></tr></table></figure>

函数结束后，局部变量会销毁，正常来说就不能再访问，但是js开了洞，在返回的函数里面保存了局部变量的副本，这个特性叫做闭包。

思考：如果闭包的作用是封装工具为其他人使用，那么直接定义一个函数传参数进去不就好了？为什么多此一举函数里面套函数呢？可见闭包的关键作用不在于此。所以：

应用：**实现数据的私有**。

![image-20240923172130454](../images/image-20240923172130454.png)  

缺点：**内存泄露**。

**为什么**会内存泄漏？因为全局作用域获取了闭包外层函数（outer）,闭包外层函数的返回值又是内部函数（fn）,fn 引用了外部变量，这些指向关系会让函数内部的变量不会销毁，因此只要页面不关闭（全局变量的回收条件是会话结束），顺着指向关系局部变量就不会回收，有可能导致内存泄漏。

#### 四.变量提升

仅存在于var未声明的情况，不是好事。 

运行机制：在js代码执行前，会扫描所有var关键字声明的变量，并把它**提升到当前作用域的最前面**。（只提升声明，不提升赋值）

#### 五.函数进阶

##### 函数提升

跟var类似，会把所有**函数声明提升到当前作用域的最前面**，只提升变量声明，不提升函数的调用。

若使用函数表达式，则不会出现这种情况，推荐。

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var fun =funciton()&#123;</span><br><span class="line">	console.log(&quot;&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//其实就是</span><br><span class="line">var fun;</span><br><span class="line">fun() //报错，因为不知道是函数</span><br><span class="line">fun=function()&#123;&#125;</span><br></pre></td></tr></table></figure>



##### 函数参数

- 动态参数
- 剩余参数

**动态参数**

**每个函数**里面都有一个**arguments属性**，本质是**伪数组**,用于**存放所有参数**。

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let fn=function()&#123;</span><br><span class="line">	//伪数组不继承数组的方法！！不能直接用！！</span><br><span class="line">	// 使用Array.from  </span><br><span class="line">	for (let value of Array.from(args)) 	&#123;  </span><br><span class="line">	  console.log(value);  </span><br><span class="line">	&#125;  </span><br><span class="line">  </span><br><span class="line">	// 使用扩展运算符  </span><br><span class="line">	for (let value of [...args]) &#123;  </span><br><span class="line">	  console.log(value);  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(1,2,3)</span><br></pre></td></tr></table></figure>

**剩余参数**

位于参数最末端，可以**取剩余的参数**，且是**真数组**。**推荐**

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let fn=function(a,...arr)&#123;</span><br><span class="line">	for(let ele of arr)&#123;</span><br><span class="line">		console.log(ele)//依次打印数组元素</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">fn(1,2,3)</span><br></pre></td></tr></table></figure>



##### 展开运算符

…

**写在函数里的是剩余参数，写在其他位置的是展开运算符。**

补充：**不会修改原数组**。

常用情况：

1. 传参时将数组转换为普通类型变量；
2. 合并数组；
3. 将数组拆分，如将后端数据（加入都需要）直接放入data中。



##### 箭头函数

适用于那些**本来需要匿名函数**的地方。

语法：

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const fn =()=&gt;&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">const fn = (a,b) =&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">const fn = a =&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">const fn = a =&gt;console.log(a)</span><br><span class="line">const fn = a =&gt; a //return a</span><br><span class="line"></span><br><span class="line">//若要返回一个对象，为避免和块冲突，要包裹一个括号</span><br><span class="line">const fn = name=&gt;(&#123;uname:name&#125;)</span><br><span class="line">fn(name)</span><br></pre></td></tr></table></figure>

注意：

1. **箭头函数没有arguments参数，但是有剩余参数…args**。
2. 箭头函数不会创建this,他**只会从自己的作用域链的上一层沿用this**。

又是一些很烦的东西：

- **函数作为方法被调用时，函数作用域不起作用**！！！！
- 对象内部的{}只是一种语法，没有作用域！！跟if和for

若调用对象里的**普通函数**，那么**谁调用，this就指向谁**；



函数作用域主要关注的是函数定义时的作用域链，它决定了函数内部如何访问外部变量。**但是**，当函数作为对象的方法被调用时，`this`的值并不是由函数作用域决定的，而**是由调用该函数的方式决定的。**

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//eg1</span><br><span class="line">const fn=()=&gt;&#123;</span><br><span class="line">	console.log(this)</span><br><span class="line">&#125;</span><br><span class="line">fn()//window</span><br><span class="line"></span><br><span class="line">//因为作用域内没有创建this,所以他会往上一层查找，这里就是window</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//eg2</span><br><span class="line">const obj=&#123;</span><br><span class="line">	sayHi:function()&#123;</span><br><span class="line">		console.log(this)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.sayHi()//obj</span><br><span class="line">//首先，函数作为方法被调用时，函数作用域不起作用,所以sayHi内部是没有this的，谁调用它，this就指向谁</span><br><span class="line"></span><br><span class="line">//eg3</span><br><span class="line">const obj=&#123;</span><br><span class="line">	sayHi:()=&gt;&#123;</span><br><span class="line">		console.log(this)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.sayHi()//window</span><br><span class="line">//由于sayHi是一个箭头函数，它不会捕获到obj作为this的上下文。相反，它会捕获到定义时所在的上下文，这通常是在全局作用域中</span><br></pre></td></tr></table></figure>



#### 六.解构赋值

##### 数组解构 

将数据快速批量的赋值给变量。

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr=[1,2]</span><br><span class="line">const [max,min=0]=arr</span><br></pre></td></tr></table></figure>

应用：

1. 赋值
2. **交换变量**
3. 多维数组解构

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let a=1</span><br><span class="line">let b=2;//注意数组解构一定要加分号！</span><br><span class="line">[b,a]=[a,b]</span><br><span class="line"></span><br><span class="line">const arr=[1,2,[3,4]]</span><br><span class="line">const [a,b,[c,d]]=arr</span><br></pre></td></tr></table></figure>

**js前面要加分号的情况**：

1. 立即执行函数
2. 数组解构(数组开头的记得加分号)

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;funcition(a)&#123;&#125;()</span><br><span class="line"></span><br><span class="line">;[b,a]=[a,b]</span><br></pre></td></tr></table></figure>

- 参数少，变量多的情况：利用剩余参数

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [a,b,c,...args]=[1,2,3,4,5]</span><br></pre></td></tr></table></figure>

- 按需导入，忽略某些条件

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const [a,b,,d]=[1,2,3,4]</span><br><span class="line">// a 1 b 2 d 4</span><br></pre></td></tr></table></figure>

##### 对象解构

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const &#123;uname,age&#125;=&#123;uname:&#x27;pink&#x27;,age:10&#125;</span><br><span class="line"></span><br><span class="line">const &#123;uname:username,age&#125;=&#123;uname:&#x27;pink&#x27;,age:10&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

##### foreach函数

很像map，只是没有返回值，适合遍历数组对象。

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.foreach(function(item,index)&#123;</span><br><span class="line">	</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

#### 七.构造函数

##### 创建对象的三种方式

1. 对象字面量创建
2. new Object()创建（系统自带）
3. 构造函数创建（自定义）

##### 构造函数

定义：一种特殊的**函数**，用于快速**初始化对象**。

把对象公共部分抽取封装，放入构造函数中，构造函数中**无需写return**。

![image-20240925163233086](../images/image-20240925163233086.png)

##### 构造函数执行过程   ——new Pig（）

1. 创建一个空对象
2. 构造函数的this指向空对象
3. 执行构造函数代码，将形参赋给对象的属性或方法
4. 返回新对象

![image-20240925183524578](../images/image-20240925183524578.png)

##### 实例成员&静态成员

**实例化对象**的**方法和属性**属于**实例成员**。

由于每次实例化都开辟了新的空间，所以给每个实例成员附上新的属性，对构造函数和其他实例成员都是没有影响的。

![image-20240925184004505](../images/image-20240925184004505.png)

**构造函数**的**方法和属性**属于**静态成员**。

如Date.now() Math.PI() Math.random()

#### 八.内置构造函数

- Object 
- Array
- String 
- Number

当调用简单数据类型的方法或属性时，js内部会隐式的把简单数据类型**包装成对象**，那么就可以调用它的内置方法了。

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//内部悄悄转换</span><br><span class="line">const str=new String(&#x27;123&#x27;)</span><br></pre></td></tr></table></figure>

![image-20240925184914544](../images/image-20240925184914544.png)

##### Object

三个静态方法：

Object.keys      ——获取对象的所有键，返回一个**数组**

Object.values  ——获取对象的所有值，返回一个**数组**

Object.assign  ——浅拷贝对象[合并对象]，即把对象的引用地址传给目标对象（如果有多个对象都要赋值给目标对象则比较复杂，会把所有属性都放入，相同属性后面的会覆盖前面的）

assign -赋值



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const o=&#123;name:&#x27;toto&#x27;,age:10&#125;</span><br><span class="line">const newArr=Object.keys(o) //[&#x27;name&#x27;,&#x27;age&#x27;]</span><br><span class="line"></span><br><span class="line">const newArr1=Object.values(o) //[&#x27;toto&#x27;,10]</span><br><span class="line"></span><br><span class="line">const result=&#123;id:190&#125;</span><br><span class="line">Object.assign(result,o)</span><br><span class="line">console.log(result)//&#123;id:190,name:&#x27;toto&#x27;,age:10&#125;</span><br></pre></td></tr></table></figure>

##### Array

###### 常见方法

1. forEach  ——**不返回**数组，遍历数组
2. filter  ——**返回**新数组，用于**筛选符合条件**的数组 （长度改变，内容不变）
3. map  ——**返回**新数组，用于**返回修改**的数组（数组长度不变，内容改变）
4. reduce  ——**不返回**数组，返回**累计处理**的结果，常用于求和
5. from  ——**返回**数组，将**伪数组转换为真数组**

**reduce执行过程**

![image-20240925191635333](../images/image-20240925191635333.png)

总结：第一次进入时，上一个值是起始值或者第一个元素（取决于起始值有没有），当前元素就是上个值的下一个值，之后每循环一次，都把返回的值作为上一个值，自动轮转当前值，直到数组为空。

###### 其他方法

![image-20240925192402486](../images/image-20240925192402486.png)

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr.find(index=&gt;index.name==&#x27;toto&#x27;)</span><br><span class="line">//返回符合条件的对象</span><br></pre></td></tr></table></figure>

##### String

</div> 

<script>
    window.onload = detectors();
</script>
    <div class="post-footer">
    <div class="h-line-primary"></div>
    <nav class="post-nav">
        <div class="prev-item">
           
                <div class="icon arrow-left"></div>
                <div class="post-link">
                    <a href="/2024/09/21/jQuery/">Prev</a>
                </div>
            
        </div>
        <div class="next-item">
            
                <div class="icon arrow-right"></div>
                <div class="post-link">
                  <a href="/2024/09/21/git/">Next</a>  
                </div>  
            
        </div>
    </nav>
</div>

    
      <div class="post-comment">

     

     
    
    

</div>
     
  
</article>
        </div>
      </div>
      
      <div class="footer">
    <div class="flex-container">
        <div class="footer-text">
            
            
            
                Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/zoeingwingkei/frame/">Frame</a>
                
        </div>
    </div>
</div>

    </div>

    
    

  </body>
</html>
