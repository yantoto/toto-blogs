<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="John Doe">







<title>Vue3 | Hexo</title>



    <link rel="icon" href="/favicon.ico">



<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=Roboto+Mono&display=swap');
</style>



    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    




    <!-- scripts list from _config.yml -->
    
    <script src="/js/menu.js"></script>
    










  <meta name="generator" content="Hexo 7.3.0"></head>
  <body>
    <div class="mask-border">
    </div>

    <div class="wrapper">

      <div class="header">
  <div class="flex-container">
    <div class="header-inner">
      <div class="site-brand-container">
        <a href="/">
          
            Frame.
          
        </a>
      </div>
      <div id="menu-btn" class="menu-btn" onclick="toggleMenu()">
        Menu
      </div>
      <nav class="site-nav">
        <ul class="menu-list">
          
            
              <li class="menu-item">
                <a href="/">Home</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/archives/">Archive</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/categories/gallery/">Gallery</a>
              </li> 
                   
          
          
        </ul>
      </nav>
    </div>
  </div>
</div>


      <div class="main">
        <div class="flex-container">
          <article id="post">

  
    <div class="post-head">
    <div class="post-info">
        <div class="tag-list">
            
        </div>
        <div class="post-title">
            
            
                Vue3
            
            
        </div>
        <span class="post-date">
            Sep 21, 2024
        </span>
    </div>
    <div class="post-img">
        
            <div class="h-line-primary"></div>
              
    </div>
</div>
    <div class="post-content">
    <h3 id="一、创建工程"><a href="#一、创建工程" class="headerlink" title="一、创建工程"></a>一、创建工程</h3><h4 id="Vite-构架工具"><a href="#Vite-构架工具" class="headerlink" title="Vite 构架工具"></a>Vite 构架工具</h4><p>webpack和vite的区别：</p>
<p>全部加载再进入 和 进入再按需加载</p>
<p><img src="/../images/image-20240921224135841.png" alt="image-20240921224135841"></p>
<p>进入一个项目先 npm i，安装依赖。</p>
<p>总结：</p>
<ol>
<li>vite项目中，index.html是入口文件，位于项目的最外层。</li>
<li>加载index.html后，vite解析<script type='module' src='xxx'>指向的Javascript</li>
<li>vue3中通过createApp创建一个应用实例，挂载到app上</li>
</ol>
<p><strong>vue2 选项式api</strong> </p>
<p><strong>vue3 组合式api</strong></p>
<h3 id="二、setup"><a href="#二、setup" class="headerlink" title="二、setup"></a>二、setup</h3><p> <strong>vue3弱化this</strong>！！ setup中this是undefined。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">setup ()&#123;</span><br><span class="line">	//数据 </span><br><span class="line">	let name=&#x27;崔杋圭&#x27; //此时不是响应式的</span><br><span class="line">	let age=22 //此时不是响应式的</span><br><span class="line">	let tel=&#x27;15308881111&#x27;</span><br><span class="line">	</span><br><span class="line">	//方法</span><br><span class="line">	function changeName()&#123;</span><br><span class="line">		name=&#x27;toto&#x27; //注意这样修改页面不会变化</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//交出去</span><br><span class="line">	return &#123;name:name,age:age&#125;</span><br><span class="line">	//简写</span><br><span class="line">	// return &#123;name,age,changeName&#125;</span><br><span class="line">	</span><br><span class="line">	//setup的返回值也可以是一个渲染函数</span><br><span class="line">	return ()=&gt;&#x27;哈哈&#x27;</span><br><span class="line">	//这样页面会无视模版 直接显示哈哈</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h4><p><strong>setup和正常写data和methods有什么关系呢？</strong></p>
<p>首先，data和method是能和setup同存的。</p>
<p>接着，data和method是可以读出setup的东西的，但反过来不能。（但不建议这么写）</p>
<h3 id="三、ref"><a href="#三、ref" class="headerlink" title="三、ref"></a>三、ref</h3><p>创建<strong>基本类型</strong>的响应式数据,在模板中不用.value,在js中需要。</p>
<p>此外，可以定义对象类型的响应式数据。ref的应用对象底层就是reactive。</p>
<p>用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div @click=&#x27;changeName&#x27;&gt;name:&#123;&#123;name&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;Person&quot;&gt;</span><br><span class="line">	import &#123;ref&#125; from &quot;vue&quot;;</span><br><span class="line">	let name=ref(&quot;toto&quot;);</span><br><span class="line">		//这是一个reflmy对象</span><br><span class="line">	let age =ref(10);</span><br><span class="line">	function changename()&#123;</span><br><span class="line">		name.value=&quot;coco&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="四、reactive"><a href="#四、reactive" class="headerlink" title="四、reactive"></a>四、reactive</h3><p>只能定义<strong>对象类型</strong>的响应式对象 深层次 不管数据多深 不用加.value</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div @click=&#x27;changePrice&#x27;&gt;tea:&#123;&#123;tea.price&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;Person&quot;&gt;</span><br><span class="line">	import &#123;reactive&#125; from &quot;vue&quot;;</span><br><span class="line">	let tea=reactive(&#123;brand:&#x27;coco&#x27;,price:10&#125;); </span><br><span class="line">	//这是一个Proxy对象，Proxy是浏览器自带的。</span><br><span class="line">	let age =ref(10);</span><br><span class="line">	function changePrice()&#123;</span><br><span class="line">		tea.price+=10;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="reactive和ref的区别："><a href="#reactive和ref的区别：" class="headerlink" title="reactive和ref的区别："></a>reactive和ref的区别：</h4><p>ref在js层面必须加.value(或者Vue .office插件配置)</p>
<p>reactive 配一个对象时，他会失去响应式。</p>
<p>场景：修改对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let tea=reactive(&#123;brand:&#x27;coco&#x27;,price:10&#125;); </span><br><span class="line"></span><br><span class="line">function change()&#123;</span><br><span class="line">	tea=&#123;brand:&#x27;coco&#x27;,price:10&#125;;// 这么写页面不更新</span><br><span class="line">	tea=reactive(&#123;brand:&#x27;coco&#x27;,price:10&#125;)// 这么写页面不更新</span><br><span class="line">	</span><br><span class="line">	//reactive绑定</span><br><span class="line">	Object.assign(tea,&#123;brand:&#x27;guMing&#x27;,price:20&#125;)</span><br><span class="line">	</span><br><span class="line">	//ref绑定</span><br><span class="line">	tea.value=&#123;brand:&#x27;guMing&#x27;,price:20&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说白了就是ref修改的是对象下面的属性，不会替换整个对象。</p>
<h3 id="五、toRef和toRefs"><a href="#五、toRef和toRefs" class="headerlink" title="五、toRef和toRefs"></a>五、toRef和toRefs</h3><p>应用场景：使解构出来的属性依旧具有响应式功能，类似指针，修改一个另一个跟着变化。</p>
<p><img src="/../images/image-20240921224147034.png"></p>
<p><img src="/../images/image-20240921224154677.png" alt="image-20240921224154677"></p>
<p>结构赋值的作用相当于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let name=person.name</span><br></pre></td></tr></table></figure>

<p>我把这里理解为把<strong>值传递</strong>过去，但reactive性质消失了。</p>
<p>如何变成响应式的？</p>
<h4 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs"></a>toRefs</h4><p>此时，把<strong>地址</strong>拷贝过去，name变化，person.name跟着变化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let &#123;name,age&#125;=toRefs(person)</span><br></pre></td></tr></table></figure>

<p>toRefs会把person里面的所有属性都变为ObjectReflmy对象，自然，解构下来就是单个对象了。</p>
<p>打印toRefs对象：</p>
<p><img src="/../images/image-20240921224203305.png" alt="image-20240921224203305"></p>
<h4 id="toRef"><a href="#toRef" class="headerlink" title="toRef"></a>toRef</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let nl=toRef(person,&#x27;age&#x27;)</span><br></pre></td></tr></table></figure>

<p>toRefs 和 toRef <strong>区别</strong>：</p>
<p>torefs把全部属性都转化为响应式对象，而toRef把指定的单个属性转化为响应式对象。</p>
<h3 id="六、computed"><a href="#六、computed" class="headerlink" title="六、computed"></a>六、computed</h3><p>vue3里的计算属性是一个函数，返回值。</p>
<p>计算属性是有<strong>缓存</strong>的，只要计算属性内部的值没有改变，那么他就会拿着上一次的值进行渲染。</p>
<p>而方法没有缓存，这就是两者的差别。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//只读</span><br><span class="line">import &#123;computed&#125; from &quot;vue&quot;</span><br><span class="line">let fullName=computed(()=&gt;&#123;</span><br><span class="line">	return 	firstName.value.slice(0,1).toUpperCase()+firstName.value.slice(1)+&#x27;-&#x27;+lastName.value</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//可读可写</span><br><span class="line">let let fullName=computed(&#123;</span><br><span class="line">	get()&#123;</span><br><span class="line">	return 	firstName.value.slice(0,1).toUpperCase()+firstName.value.slice(1)+&#x27;-&#x27;+lastName.value</span><br><span class="line">	&#125;</span><br><span class="line">	set(val)&#123;</span><br><span class="line">	const [str1,str2]=val.split(&#x27;-&#x27;)</span><br><span class="line">	firstName.value=str1;</span><br><span class="line">	laseName.value=str2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fullName.value=&#x27;to-to&#x27;//调用了set函数，并给原始数据赋值</span><br></pre></td></tr></table></figure>

<h3 id="七、watch"><a href="#七、watch" class="headerlink" title="七、watch"></a>七、watch</h3><h4 id="1-监视ref定义的基本类型数据"><a href="#1-监视ref定义的基本类型数据" class="headerlink" title="1.监视ref定义的基本类型数据"></a>1.监视ref定义的基本类型数据</h4><p><img src="/../images/image-20240921224210803.png" alt="image-20240921224210803"></p>
<p>新点：watchf返回值是一个<strong>停止监视</strong>函数，调用这个函数就会停止监视（就是这里的stopWatch）</p>
<h4 id="2-监视ref定义的对象类型数据"><a href="#2-监视ref定义的对象类型数据" class="headerlink" title="2.监视ref定义的对象类型数据"></a>2.监视ref定义的对象类型数据</h4><p><img src="/../images/image-20240921224217787.png"></p>
<p>注意：其实监视的就是<strong>地址的变化</strong>，若想要监视每个属性的变化，需要开启deep：true</p>
<h4 id="3-监视reactive定义的对象类型数据"><a href="#3-监视reactive定义的对象类型数据" class="headerlink" title="3.监视reactive定义的对象类型数据"></a>3.监视reactive定义的对象类型数据</h4><p>隐式开启深度监视</p>
<p><img src="/../images/image-20240921224225395.png" alt="image-20240921224225395"></p>
<h4 id="4-监视ref或者reactive定义的对象类型数据中的某个属性"><a href="#4-监视ref或者reactive定义的对象类型数据中的某个属性" class="headerlink" title="4.监视ref或者reactive定义的对象类型数据中的某个属性"></a>4.监视ref或者reactive定义的对象类型数据中的某个属性</h4><p><img src="/../images/image-20240921224233620.png" alt="image-20240921224233620"></p>
<p>为什么基本对象写成函数形式就可以？因为<strong>watch只能监视这四种</strong>：</p>
<ol>
<li><strong>ref对象类型</strong></li>
<li><strong>reactive对象类型</strong></li>
<li><strong>一个返回值的函数（其实就是getter）</strong>，监视的就是地址值</li>
<li><strong>包括这些类型的数组</strong></li>
</ol>
<h4 id="5-监视上述多个数据"><a href="#5-监视上述多个数据" class="headerlink" title="5.监视上述多个数据"></a>5.监视上述多个数据</h4><p><img src="/../images/image-20240921224239054.png" alt="image-20240921224239054"></p>
<p>结论：</p>
<p>​	<strong>函数式一把梭哈</strong></p>
<h3 id="八、watchEffect"><a href="#八、watchEffect" class="headerlink" title="八、watchEffect"></a>八、watchEffect</h3><p>用到谁就监视谁，好用，自动分析，但性能一般。</p>
<p><img src="/../images/image-20240921224245798.png" alt="image-20240921224245798"></p>
<p><img src="/../images/image-20240921224252746.png" alt="image-20240921224252746"></p>
<h3 id="九、标签的ref属性"><a href="#九、标签的ref属性" class="headerlink" title="九、标签的ref属性"></a>九、标签的ref属性</h3><p>作用:用于注册模版引用</p>
<ul>
<li>用在普通dom标签上，获取的是DOM节点</li>
<li>用在组件便签上，获取的是组件实例对象。</li>
</ul>
<h3 id="十、泛型"><a href="#十、泛型" class="headerlink" title="十、泛型"></a>十、泛型</h3><p>在index.ts定义接口，用于限制格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export interface Person&#123;</span><br><span class="line"> id:string,</span><br><span class="line"> name:string,</span><br><span class="line"> age:number </span><br><span class="line">&#125;</span><br><span class="line">export type Persons=Array&lt;Person&gt;</span><br></pre></td></tr></table></figure>

<p>在vue文件中引入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123;type Person&#125; from &#x27;@/types&#x27;</span><br><span class="line">let person:Person =&#123;id:&#x27;&#x27;,name:&#x27;&#x27;,age:5&#125;</span><br><span class="line"></span><br><span class="line">let personList:Array&lt;Person&gt;=[&#123;id:&#x27;&#x27;,name:&#x27;&#x27;,</span><br><span class="line">//或者</span><br><span class="line">let personList:[Person]</span><br></pre></td></tr></table></figure>

<h3 id="十一、props"><a href="#十一、props" class="headerlink" title="十一、props"></a>十一、props</h3><p><strong>屬性前加上冒号就是把后面的当做表达式</strong>。除了ref的表达式不用加冒号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2 a=&quot;1+1&quot; :b=&quot;1+1&quot; c=&quot;x&quot; :d=&quot;x&quot; ref=&quot;qwe&quot;&gt;測試&lt;/h2&gt;</span><br><span class="line">let x=9;</span><br><span class="line"></span><br><span class="line">//a=1+1 b=2 c=x d=9</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="使用props："><a href="#使用props：" class="headerlink" title="使用props："></a>使用props：</h4><h5 id="父组件"><a href="#父组件" class="headerlink" title="父组件"></a>父组件</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;Person a=&#x27;哈哈&#x27; :list=&#x27;personList&#x27;&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;App&quot;&gt;</span><br><span class="line">    let  personList:[Person]=[&#123;...&#125;]</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h5 id="子组件"><a href="#子组件" class="headerlink" title="子组件"></a>子组件</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;h2&gt;&#123;&#123;a&#125;&#125;&lt;/h2&gt;</span><br><span class="line">	&lt;ul&gt;</span><br><span class="line">        &lt;li v-for=&quot;p in list&quot; :key=&quot;p.id&quot;&gt;</span><br><span class="line">            &#123;&#123;p.name&#125;&#125;--&#123;&#123;p.age&#125;&#125;</span><br><span class="line">    	&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;App&quot;&gt;</span><br><span class="line">    import &#123;defineProps,withDefault&#125; from &#x27;vue&#x27;</span><br><span class="line">    import &#123;type Persons&#125; from &quot;@/itypes&quot;</span><br><span class="line">    // export type Persons=Array&lt;Person&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //只接收list</span><br><span class="line">    let x=defineProps([&#x27;a&#x27;,&#x27;list&#x27;])</span><br><span class="line">    console.log(x)</span><br><span class="line">    //&#123;a:&quot;哈哈&quot;，list:[&#123;...&#125;]&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //接受list+限制类型</span><br><span class="line">    defineProps&lt;&#123;list:Persons&#125;&gt;()</span><br><span class="line">    </span><br><span class="line">     //接受list+限制类型+限制必要性+制定默认值</span><br><span class="line">   withDefaults(defineProps&lt;&#123;list?:Persons&#125;&gt;(),&#123;</span><br><span class="line">        list:()=&gt;[&#123;id:&#x27;11&#x27;,name:&#x27;toto&#x27;,age:19&#125;]</span><br><span class="line">    &#125;) </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="十二、组件的生命周期"><a href="#十二、组件的生命周期" class="headerlink" title="十二、组件的生命周期"></a>十二、组件的生命周期</h3><p>两个版本都有四大步：<strong>创建 created 挂载 mounted 更新 updated 销毁  destroyed</strong></p>
<h4 id="vue2八大钩子：-还有更多"><a href="#vue2八大钩子：-还有更多" class="headerlink" title="vue2八大钩子：(还有更多)"></a>vue2八大钩子：(还有更多)</h4><ol>
<li>beforeCreate</li>
<li>Created</li>
<li>beforeMount</li>
<li>mounted</li>
<li>beforeUpdate</li>
<li>updated</li>
<li>beforeDestroy</li>
<li>destroyed</li>
</ol>
<h4 id="vue3七大："><a href="#vue3七大：" class="headerlink" title="vue3七大："></a>vue3七大：</h4><p><strong>创建 setup 挂载 Mounted 更新 Updated  卸载 Unmount</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import &#123;onBeforeMount,onMounted,onBeforeUpdate....&#125;</span><br><span class="line">console.log(&#x27;创建&#x27;)</span><br><span class="line">onBeforeMount(()=&gt;&#123;</span><br><span class="line">	console.log(&#x27;挂載前&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">onMounted(()=&gt;&#123;</span><br><span class="line">	console.log(&#x27;挂載完毕&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">onBeforeUpdate(()=&gt;&#123;</span><br><span class="line">	console.log(&#x27;更新前&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">onUpdated(()=&gt;&#123;</span><br><span class="line">	console.log(&#x27;更新完毕&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">onBeforeUnmount(()=&gt;&#123;</span><br><span class="line">	console.log(&#x27;卸载前&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">onUnmount(()=&gt;&#123;</span><br><span class="line">	console.log(&#x27;卸载完毕&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>面试题：子组件先挂载还是父？</p>
<p>答案：子。父组件得等子组件和子子组件挂载完成（深度遍历）才算完成</p>
<h3 id="十三、hooks"><a href="#十三、hooks" class="headerlink" title="十三、hooks"></a>十三、hooks</h3><p>数据和方法<strong>集中管理</strong>，类似于mixin.</p>
<p>并且hooks里面可以写钩子，计算属性等。</p>
<p><img src="/../images/image-20240921224301891.png" alt="image-20240921224301891"></p>
<p><img src="/../images/image-20240921224308298.png" alt="image-20240921224308298"></p>
<p><img src="/../images/image-20240921224314740.png" alt="image-20240921224314740"></p>
<h3 id="十四、路由"><a href="#十四、路由" class="headerlink" title="十四、路由"></a>十四、路由</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>1.路由规则其实是<strong>键值对</strong>的对应关系。</p>
<p>2.它的改变会对应路径的变化。</p>
<p>3.路由切换页面<strong>不抖动，不刷新</strong>。</p>
<h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ol>
<li>引入createRouter和createWebHistory，并引入组件</li>
<li>注册路由router</li>
<li>指定工作模式</li>
<li>设计routes对应关系</li>
<li>导出router</li>
<li>在main.ts中引入并使用router</li>
</ol>
<p><img src="/../images/image-20240921224321688.png" alt="image-20240921224321688"></p>
<p><img src="/../images/image-20240921224327320.png" alt="image-20240921224327320"></p>
<p><img src="/../images/image-20240921224333016.png" alt="image-20240921224333016"></p>
<p>​	这里的<strong>active-class</strong>使开发更方便。</p>
<p><strong>开发规范</strong>：一般组件放components文件夹，路由组件放pages或views文件夹。</p>
<h4 id="工作模式："><a href="#工作模式：" class="headerlink" title="工作模式："></a>工作模式：</h4><ul>
<li><strong>history模式</strong>：</li>
</ul>
<p>​	Vue2：mode:’history’</p>
<p>​	Vue3:   history:createWebHistory()</p>
<p>优点:路径<strong>没有#<strong>，更</strong>美观</strong>。</p>
<p>缺点：后期项目上线，需要<strong>服务端配合处理路径问题</strong>，否则刷新会有404。</p>
<p>怎么处理？后端的事别管。</p>
<ul>
<li><strong>hash模式</strong>：</li>
</ul>
<p>优点：兼容性更好，服务器不用处理路径。</p>
<p>缺陷：url带有#，且在SEO优化方面相对较差。</p>
<p>routerLnk跳转方式：</p>
<p>字符串 和 对象跳转。</p>
<p><img src="/../images/image-20240921224339569.png" alt="image-20240921224339569"></p>
<h4 id="路由传参："><a href="#路由传参：" class="headerlink" title="路由传参："></a>路由传参：</h4><p><strong>qurey 和 params</strong></p>
<h5 id="qurey-推荐"><a href="#qurey-推荐" class="headerlink" title="qurey :(推荐)"></a>qurey :(推荐)</h5><p>发送</p>
<p>1.直接写在字符串里。</p>
<p><img src="/../images/image-20240921224345704.png" alt="image-20240921224345704"></p>
<p>2.对象写法，写配置项</p>
<p><img src="/../images/image-20240921224351792.png" alt="image-20240921224351792"></p>
<p>接收</p>
<p><img src="/../images/image-20240921224358106.png" alt="image-20240921224358106"></p>
<h5 id="params"><a href="#params" class="headerlink" title="params:"></a>params:</h5><p><img src="/../images/image-20240921224405383.png" alt="image-20240921224405383"></p>
<p>第一种写法需要在route里面给参数占位。</p>
<p>eg:  path:’detail/:id/:title/:content?’ ?可传可不传。</p>
<p>第二种写法不能用path指定跳转，必须用name。</p>
<h4 id="路由规则的props配置："><a href="#路由规则的props配置：" class="headerlink" title="路由规则的props配置："></a>路由规则的props配置：</h4><p>优点：简化了template中的参数前缀。</p>
<p>写法一：把路由收到的所有<strong>params参数</strong>转换为props参数。</p>
<p><img src="/../images/image-20240921224411827.png" alt="image-20240921224411827"></p>
<p>写法二：函数写法，可以自己决定传递的参数。</p>
<p><img src="/../images/image-20240921224417743.png" alt="image-20240921224417743"></p>
<h4 id="replace属性："><a href="#replace属性：" class="headerlink" title="replace属性："></a>replace属性：</h4><p>push模式（推入栈内，形成历史记录） 和 replace模式（直接替换，无历史，可用于登录）。</p>
<h4 id="编程式路由跳转："><a href="#编程式路由跳转：" class="headerlink" title="编程式路由跳转："></a>编程式路由跳转：</h4><p><img src="/../images/image-20240921224423494.png" alt="image-20240921224423494"></p>
<p>to里面写法是什么，router.push或者router.repalce里面写法也一样。</p>
<h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>让指定路径重新定义到另一个路径。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	path:&#x27;/&#x27;,</span><br><span class="line">	redirect:&#x27;/home&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="十五、pinia"><a href="#十五、pinia" class="headerlink" title="十五、pinia"></a>十五、pinia</h3><p>集中式状态（数据）管理，大仓库，把<strong>共享的数据</strong>放在里面。</p>
<p>vue2用vuex,vue3用pinia，数据保存在store文件夹。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h5 id="选项式"><a href="#选项式" class="headerlink" title="选项式"></a>选项式</h5><p><img src="/../images/image-20240921224429893.png" alt="image-20240921224429893"></p>
<h5 id="组合式（vue3写法）"><a href="#组合式（vue3写法）" class="headerlink" title="组合式（vue3写法）"></a>组合式（vue3写法）</h5><p>其实这里有点<strong>类似于hooks</strong>了。</p>
<p><img src="/../images/image-20240921224435717.png" alt="image-20240921224435717"></p>
<p><img src="/../images/image-20240921224440957.png" alt="image-20240921224440957"></p>
<h3 id="十六、组件通信"><a href="#十六、组件通信" class="headerlink" title="十六、组件通信"></a>十六、组件通信</h3><h4 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h4><p>对象：<strong>父给子</strong>直接传递数据，<strong>子给父</strong>间接传递数据（调用父传过来的函数实现数据传递）</p>
<ul>
<li>父给子传递<strong>数据</strong>，子调用defineProps接收，直接在模版使用。</li>
<li>父给子传递<strong>函数</strong>，先在父里的定义该函数，再用标签传递，子调用defineProps接收，直接在模版调用。</li>
</ul>
<p><img src="/../images/image-20240921224446397.png" alt="image-20240921224446397"></p>
<h4 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h4><p>对象：<strong>子给父间接</strong>传递数据（利用父组件绑定的函数，当该函数在子组件触发时，父组件中响应的函数也会触发）</p>
<p>跟props子传父好像啊，逻辑差不多，就是写法不同。</p>
<p><strong>区别</strong>：自定义事件**=后面<strong>的参数是</strong>父<strong>函数里的，而props</strong>=前面**的参数是父函数里的.（哇，我这史概括能力）</p>
<p><strong>自定义事件里的属性名是给儿子用的，而prop里的属性名就是给父亲本身用的。</strong></p>
<p><img src="/../images/image-20240921224452069.png" alt="image-20240921224452069"></p>
<p>知识点：如果模版里函数<strong>参数没有传递</strong>，那么js里面接收的就是点击事件。</p>
<p><img src="/../images/image-20240921224458259.png" alt="image-20240921224458259"></p>
<p>传递其它参数和点击事件写法：</p>
<p><img src="/../images/image-20240921224510788.png" alt="image-20240921224510788"></p>
<h4 id="mitt"><a href="#mitt" class="headerlink" title="mitt"></a>mitt</h4><p>类似于vur2的事件总线（发布与订阅），实现任意组件通信。</p>
<p>对象：<strong>任意组件</strong>，<strong>接收数据的一方绑定函数，发送数据的一方触发函数</strong>，并传参。</p>
<p><img src="/../images/image-20240921224517208.png"></p>
<p><img src="/../images/image-20240921224523853.png" alt="image-20240921224523853"></p>
<h4 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h4><p>v-model的<strong>底层原理</strong>：</p>
<p><strong>: value</strong>配合上<strong>绑定input事件函数</strong>，在函数内部拿到事件的事件对象，再从中取到输入框的值赋给username。</p>
<p>v-model技能既能父传子，也能子传父。</p>
<p><img src="/../images/image-20240921224529881.png" alt="image-20240921224529881"></p>
<p>场景：封装一个inputUI组件库，实现与界面的双向绑定。</p>
<p><img src="/../images/image-20240921224536095.png" alt="image-20240921224536095"></p>
<p><strong>$event定义</strong></p>
<p><img src="/../images/image-20240921224542197.png" alt="image-20240921224542197"></p>
<h4 id="attrs"><a href="#attrs" class="headerlink" title="$attrs"></a>$attrs</h4><p>对象：祖先</p>
<p>原理：父传子若props未接收，那么未接收的属性会在attrs里。子属性只需把$attrs利用props传递给孙，那么孙可以直接用definedProps接收。</p>
<p>我觉得本质还是props，只是<strong>多出了attrs来存储未被props接收的数据</strong>。</p>
<p>注意：这里的v-bind=“{x:100,y:200}”就相当于 :x=“100” :y=“200”。</p>
<p>父：</p>
<p><img src="/../images/image-20240921224548692.png" alt="image-20240921224548692"></p>
<p>子和孙：</p>
<p><img src="/../images/image-20240921224607593.png" alt="image-20240921224607593"></p>
<h4 id="refs-和-parents"><a href="#refs-和-parents" class="headerlink" title="$refs 和  parents"></a>$refs 和  parents</h4><p>如何把<strong>子的数据暴露给父</strong>？</p>
<p>子利用defineExpose暴露数据，父组件利用ref接收，并可以修改子里的数据（我觉得这里是个双向绑定或者父拿到了子数据的地址，可以直接进行修改）</p>
<p><img src="/../images/image-20240921224614127.png" alt="image-20240921224614127"></p>

</div> 

<script>
    window.onload = detectors();
</script>
    <div class="post-footer">
    <div class="h-line-primary"></div>
    <nav class="post-nav">
        <div class="prev-item">
           
                <div class="icon arrow-left"></div>
                <div class="post-link">
                    <a href="/2024/09/21/webpack/">Prev</a>
                </div>
            
        </div>
        <div class="next-item">
            
                <div class="icon arrow-right"></div>
                <div class="post-link">
                  <a href="/2024/09/21/Vue/">Next</a>  
                </div>  
            
        </div>
    </nav>
</div>

    
      <div class="post-comment">

     

     
    
    

</div>
     
  
</article>
        </div>
      </div>
      
      <div class="footer">
    <div class="flex-container">
        <div class="footer-text">
            
            
            
                Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/zoeingwingkei/frame/">Frame</a>
                
        </div>
    </div>
</div>

    </div>

    
    

  </body>
</html>
